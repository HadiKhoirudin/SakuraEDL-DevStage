// ============================================================================
// LoveAlways - Exploit Service
// Integrates chip information reading and vulnerability exploitation
// ============================================================================

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Eng Translation by iReverse - HadiKIT - Hadi Khoirudin, S.Kom.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using System;
using System.IO.Ports;
using System.Threading;
using System.Threading.Tasks;
using LoveAlways.Qualcomm.Database;

namespace LoveAlways.Qualcomm.Exploit
{
    /// <summary>
    /// Exploit Service - Provides high-level interface
    /// </summary>
    public class ExploitService
    {
        private readonly Action<string> _log;
        private readonly PblExploit _exploit;
        
        // Latest vulnerability check result
        public VulnerabilityCheckResult LastCheckResult { get; private set; }
        
        // Whether exploit is enabled
        public bool EnableExploit { get; set; }

        public ExploitService(Action<string> log = null)
        {
            _log = log ?? delegate { };
            _exploit = new PblExploit(_log);
            EnableExploit = false;  // Disabled by default
        }

        /// <summary>
        /// Check if the chip has available vulnerabilities (call after Sahara handshake)
        /// </summary>
        /// <param name="chipInfo">Chip information read via SaharaClient</param>
        /// <returns>Whether vulnerabilities are available</returns>
        public bool CheckAndReportVulnerabilities(QualcommChipInfo chipInfo)
        {
            if (chipInfo == null)
            {
                _log("[ExploitService] No chip information, skipping vulnerability detection");
                return false;
            }

            LastCheckResult = _exploit.CheckVulnerability(chipInfo);
            
            if (LastCheckResult.HasVulnerability)
            {
                // Notify user of available vulnerabilities
                _log("");
                _log("╔══════════════════════════════════════════╗");
                _log("║       Exploit Found                   ║");
                _log("╠══════════════════════════════════════════╣");
                _log(string.Format("║ Chip: {0,-32} ║", chipInfo.ChipName ?? "Unknown"));
                _log(string.Format("║ Reco: {0,-32} ║", LastCheckResult.RecommendedExploit ?? "N/A"));
                _log("╠══════════════════════════════════════════╣");
                _log("║ To use the exploit, please enable option ║");
                _log("╚══════════════════════════════════════════╝");
                _log("");
            }

            return LastCheckResult.HasVulnerability;
        }

        /// <summary>
        /// Try exploiting vulnerability (if enabled and vulnerability available)
        /// </summary>
        /// <param name="port">Serial Port</param>
        /// <param name="chipInfo">Chip Information</param>
        /// <param name="ct">Cancellation Token</param>
        /// <returns>Exploit Result</returns>
        public async Task<ExploitResult> TryExploitIfEnabledAsync(
            SerialPort port,
            QualcommChipInfo chipInfo,
            CancellationToken ct = default(CancellationToken))
        {
            // Check if enabled
            if (!EnableExploit)
            {
                _log("[ExploitService] Exploit is not enabled");
                return new ExploitResult { Success = false, Message = "Exploit is not enabled" };
            }
 
            // Check if there are available vulnerabilities
            if (LastCheckResult == null || !LastCheckResult.HasVulnerability)
            {
                var checkResult = CheckAndReportVulnerabilities(chipInfo);
                if (!checkResult)
                {
                    return new ExploitResult { Success = false, Message = "No vulnerabilities available" };
                }
            }
 
            // Execute exploit
            _log("[ExploitService] Starting exploit execution...");
            return await _exploit.TryExploitWithChipInfoAsync(port, chipInfo, ct);
        }

        /// <summary>
        /// Get Exploit Recommendation
        /// </summary>
        public string GetExploitRecommendation(QualcommChipInfo chipInfo)
        {
            if (chipInfo == null)
                return "No chip info";

            var result = ExploitDatabase.CheckVulnerabilities(
                chipInfo.MsmId,
                chipInfo.OemId,
                chipInfo.PkHash,
                0
            );

            if (!result.HasVulnerability)
                return "No known vulnerabilities for this device";
 
            return string.Format("Recommended: {0}\nReason: {1}",
                result.RecommendedExploit,
                result.Reason);
        }

        /// <summary>
        /// Quick check if chip may have vulnerabilities (short version)
        /// </summary>
        public static bool QuickCheckByMsmId(uint msmId)
        {
            return ExploitDatabase.IsChipPotentiallyVulnerable(msmId);
        }

        /// <summary>
        /// Get chip vulnerability description
        /// </summary>
        public static string GetChipVulnDescription(uint msmId)
        {
            return ExploitDatabase.GetChipVulnerabilityDescription(msmId);
        }
    }
}
