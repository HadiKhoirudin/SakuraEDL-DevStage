// ============================================================================
// LoveAlways - 漏洞数据库
// 记录已知的有漏洞芯片和厂商信息
// ============================================================================

using System;
using System.Collections.Generic;

namespace LoveAlways.Qualcomm.Exploit
{
    /// <summary>
    /// 漏洞信息
    /// </summary>
    public class VulnerabilityInfo
    {
        public ExploitType Type { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public string[] AffectedChips { get; set; }
        public string[] AffectedVendors { get; set; }
        public uint[] AffectedPblVersions { get; set; }
        public int SuccessRate { get; set; }  // 1-5 星
    }

    /// <summary>
    /// 漏洞检测结果
    /// </summary>
    public class VulnerabilityCheckResult
    {
        public bool HasVulnerability { get; set; }
        public List<VulnerabilityInfo> AvailableExploits { get; set; }
        public string RecommendedExploit { get; set; }
        public string Reason { get; set; }

        public VulnerabilityCheckResult()
        {
            AvailableExploits = new List<VulnerabilityInfo>();
        }
    }

    /// <summary>
    /// 漏洞数据库
    /// </summary>
    public static class ExploitDatabase
    {
        // ============================================================================
        // 已知有漏洞的芯片 (MSM ID)
        // ============================================================================
        private static readonly Dictionary<uint, VulnerabilityInfo> VulnerableChips = new Dictionary<uint, VulnerabilityInfo>
        {
            // SDM845 - Sahara Memory Debug 漏洞
            { 0x006b00e1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Memory Debug",
                Description = "SDM845 部分批次允许进入 Memory Debug 模式",
                AffectedChips = new[] { "SDM845" },
                SuccessRate = 3
            }},
            
            // SDM710 - Firehose 隐藏命令
            { 0x000db0e1, new VulnerabilityInfo {
                Type = ExploitType.FirehoseXmlOverflow,
                Name = "Firehose Hidden Commands",
                Description = "SDM710 部分设备支持 peek/poke 调试命令",
                AffectedChips = new[] { "SDM710" },
                SuccessRate = 2
            }},
            
            // SDM670 - 签名绕过 (部分 unfused)
            { 0x000910e1, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Unfused Device",
                Description = "SDM670 部分工程机未烧录安全熔丝",
                AffectedChips = new[] { "SDM670" },
                SuccessRate = 4
            }},
            
            // MSM8998 - Sahara ReadData 溢出
            { 0x0005f0e1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara ReadData Overflow",
                Description = "MSM8998 部分版本存在 ReadData 缓冲区溢出",
                AffectedChips = new[] { "MSM8998" },
                SuccessRate = 2
            }},
            
            // MSM8996 - 经典 EDL 漏洞
            { 0x0007c0e1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "EDL Classic Exploit",
                Description = "MSM8996 存在多个已知 EDL 漏洞",
                AffectedChips = new[] { "MSM8996" },
                SuccessRate = 4
            }},
            
            // MSM8953 - Sahara 漏洞
            { 0x0009a0e1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "MSM8953 部分版本存在 Sahara 协议漏洞",
                AffectedChips = new[] { "MSM8953" },
                SuccessRate = 3
            }},
            
            // MSM8937 - 旧版 PBL 漏洞
            { 0x000940e1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Legacy PBL Exploit",
                Description = "MSM8937 旧版 PBL 存在多个漏洞",
                AffectedChips = new[] { "MSM8937" },
                SuccessRate = 4
            }},
        };

        // ============================================================================
        // 已知有漏洞的厂商 OEM ID
        // ============================================================================
        private static readonly Dictionary<ushort, VulnerabilityInfo> VulnerableVendors = new Dictionary<ushort, VulnerabilityInfo>
        {
            // 某些厂商的工程机可能未锁定
            { 0x0000, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Unfused/Engineering Device",
                Description = "OEM ID 为 0，可能是工程机或 unfused 设备",
                AffectedVendors = new[] { "Unknown/Engineering" },
                SuccessRate = 5
            }},
        };

        // ============================================================================
        // 已知有漏洞的 PK Hash 前缀
        // ============================================================================
        private static readonly Dictionary<string, VulnerabilityInfo> VulnerablePkHash = new Dictionary<string, VulnerabilityInfo>
        {
            // 泄露的测试密钥
            { "00000000", new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Test Key / Unfused",
                Description = "PK Hash 全零，设备未熔断或使用测试密钥",
                SuccessRate = 5
            }},
        };

        // ============================================================================
        // 已知有漏洞的 PBL 版本
        // ============================================================================
        private static readonly Dictionary<uint, VulnerabilityInfo> VulnerablePblVersions = new Dictionary<uint, VulnerabilityInfo>
        {
            { 0x00000001, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "PBL v1 Sahara Exploit",
                Description = "PBL 版本 1 存在 Sahara 协议漏洞",
                SuccessRate = 4
            }},
            { 0x00000002, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "PBL v2 Sahara Exploit",
                Description = "PBL 版本 2 存在 Sahara 协议漏洞",
                SuccessRate = 3
            }},
        };

        /// <summary>
        /// 根据芯片信息检测可用漏洞
        /// </summary>
        /// <param name="msmId">MSM ID (芯片ID)</param>
        /// <param name="oemId">OEM ID (厂商ID)</param>
        /// <param name="pkHash">PK Hash (前8位即可)</param>
        /// <param name="pblVersion">PBL 版本 (可选)</param>
        /// <returns>漏洞检测结果</returns>
        public static VulnerabilityCheckResult CheckVulnerabilities(
            uint msmId, 
            ushort oemId, 
            string pkHash, 
            uint pblVersion = 0)
        {
            var result = new VulnerabilityCheckResult();

            // 1. 检查芯片是否有已知漏洞
            VulnerabilityInfo chipVuln;
            if (VulnerableChips.TryGetValue(msmId, out chipVuln))
            {
                result.HasVulnerability = true;
                result.AvailableExploits.Add(chipVuln);
            }

            // 2. 检查厂商是否有已知漏洞
            VulnerabilityInfo vendorVuln;
            if (VulnerableVendors.TryGetValue(oemId, out vendorVuln))
            {
                result.HasVulnerability = true;
                result.AvailableExploits.Add(vendorVuln);
            }

            // 3. 检查 PK Hash 是否有已知漏洞
            if (!string.IsNullOrEmpty(pkHash) && pkHash.Length >= 8)
            {
                string prefix = pkHash.Substring(0, 8).ToLower();
                VulnerabilityInfo pkVuln;
                if (VulnerablePkHash.TryGetValue(prefix, out pkVuln))
                {
                    result.HasVulnerability = true;
                    result.AvailableExploits.Add(pkVuln);
                }
            }

            // 4. 检查 PBL 版本是否有已知漏洞
            if (pblVersion > 0)
            {
                VulnerabilityInfo pblVuln;
                if (VulnerablePblVersions.TryGetValue(pblVersion, out pblVuln))
                {
                    result.HasVulnerability = true;
                    result.AvailableExploits.Add(pblVuln);
                }
            }

            // 5. 确定推荐的漏洞利用方式
            if (result.HasVulnerability && result.AvailableExploits.Count > 0)
            {
                // 按成功率排序，选择最高的
                VulnerabilityInfo best = result.AvailableExploits[0];
                foreach (var vuln in result.AvailableExploits)
                {
                    if (vuln.SuccessRate > best.SuccessRate)
                        best = vuln;
                }
                result.RecommendedExploit = best.Name;
                result.Reason = best.Description;
            }

            return result;
        }

        /// <summary>
        /// 获取芯片的漏洞描述
        /// </summary>
        public static string GetChipVulnerabilityDescription(uint msmId)
        {
            VulnerabilityInfo info;
            if (VulnerableChips.TryGetValue(msmId, out info))
            {
                return string.Format("{0} ({1}★)", info.Name, info.SuccessRate);
            }
            return null;
        }

        /// <summary>
        /// 判断芯片是否可能有漏洞
        /// </summary>
        public static bool IsChipPotentiallyVulnerable(uint msmId)
        {
            // 已知有漏洞的芯片
            if (VulnerableChips.ContainsKey(msmId))
                return true;

            // 2018年之前的芯片更可能有漏洞
            // MSM8xxx 系列 (旧架构)
            if ((msmId & 0x00FF0000) == 0)
                return true;

            return false;
        }

        /// <summary>
        /// 判断是否为 unfused 设备
        /// </summary>
        public static bool IsUnfusedDevice(ushort oemId, string pkHash)
        {
            // OEM ID 为 0
            if (oemId == 0)
                return true;

            // PK Hash 全零
            if (!string.IsNullOrEmpty(pkHash) && pkHash.StartsWith("00000000"))
                return true;

            return false;
        }
    }
}
