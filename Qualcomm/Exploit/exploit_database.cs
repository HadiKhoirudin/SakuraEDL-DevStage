// ============================================================================
// LoveAlways - Exploit Database
// Records known vulnerable chips and vendor information
// ============================================================================

using System;
using System.Collections.Generic;

namespace LoveAlways.Qualcomm.Exploit
{
    /// <summary>
    /// Vulnerability information
    /// </summary>
    public class VulnerabilityInfo
    {
        public ExploitType Type { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }
        public string[] AffectedChips { get; set; }
        public string[] AffectedVendors { get; set; }
        public uint[] AffectedPblVersions { get; set; }
        public int SuccessRate { get; set; }  // 1-5 stars
    }

    /// <summary>
    /// Vulnerability check result
    /// </summary>
    public class VulnerabilityCheckResult
    {
        public bool HasVulnerability { get; set; }
        public List<VulnerabilityInfo> AvailableExploits { get; set; }
        public string RecommendedExploit { get; set; }
        public string Reason { get; set; }

        public VulnerabilityCheckResult()
        {
            AvailableExploits = new List<VulnerabilityInfo>();
        }
    }

    /// <summary>
    /// Exploit database
    /// </summary>
    public static class ExploitDatabase
    {
        // Known vulnerable chips (MSM ID)
        // ============================================================================
        private static readonly Dictionary<uint, VulnerabilityInfo> VulnerableChips = new Dictionary<uint, VulnerabilityInfo>
        {
            // ======================= Snapdragon 8xx Series =======================
            
            // SDM845 - Sahara Memory Debug exploit
            { 0x0008B0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Memory Debug",
                Description = "Certain batches of SDM845 allow entering Memory Debug mode",
                AffectedChips = new[] { "SDM845", "SDA845" },
                SuccessRate = 3
            }},
            
            // MSM8998 - Sahara ReadData Overflow
            { 0x0005E0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara ReadData Overflow",
                Description = "Certain versions of MSM8998 (Snapdragon 835) have ReadData buffer overflow",
                AffectedChips = new[] { "MSM8998", "APQ8098" },
                SuccessRate = 3
            }},
            
            // MSM8996/MSM8996Pro - Classic EDL Exploit
            { 0x009470E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "EDL Classic Exploit",
                Description = "MSM8996 (Snapdragon 820) has multiple known EDL exploits",
                AffectedChips = new[] { "MSM8996", "APQ8096" },
                SuccessRate = 4
            }},
            { 0x0005F0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "EDL Classic Exploit (821)",
                Description = "MSM8996Pro (Snapdragon 821) has known EDL exploit",
                AffectedChips = new[] { "MSM8996Pro" },
                SuccessRate = 4
            }},
            
            // MSM8994 - Snapdragon 810 vulnerability
            { 0x009400E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Exploit (810)",
                Description = "Legacy PBL of MSM8994 (Snapdragon 810) has vulnerabilities",
                AffectedChips = new[] { "MSM8994", "APQ8094" },
                SuccessRate = 4
            }},
            
            // ======================= Snapdragon 7xx Series =======================
            
            // SDM710 - Firehose Hidden Commands
            { 0x000DB0E1, new VulnerabilityInfo {
                Type = ExploitType.FirehoseXmlOverflow,
                Name = "Firehose Hidden Commands",
                Description = "Certain SDM710 (Snapdragon 710) devices support peek/poke debug commands",
                AffectedChips = new[] { "SDM710", "SDA710" },
                SuccessRate = 2
            }},
            
            // SDM670 - Signature Bypass (Certain unfused)
            { 0x000910E1, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Unfused Device",
                Description = "Certain SDM670 (Snapdragon 670) engineering devices have unfused security fuses",
                AffectedChips = new[] { "SDM670", "SDA670" },
                SuccessRate = 4
            }},
            
            // SDM660 - Signature Bypass
            { 0x0008C0E1, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Loader Signature Bypass",
                Description = "Certain versions of SDM660 (Snapdragon 660) can load unsigned Loader",
                AffectedChips = new[] { "SDM660", "SDA660" },
                SuccessRate = 3
            }},
            
            // ======================= Snapdragon 6xx Series =======================
            
            // SDM636/632 - Sahara Vulnerability
            { 0x000CC0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "SDM636 (Snapdragon 636) certain versions have Sahara protocol vulnerabilities",
                AffectedChips = new[] { "SDM636", "SDA636" },
                SuccessRate = 3
            }},
            { 0x000BA0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "SDM632 (Snapdragon 632) certain versions have Sahara protocol vulnerabilities",
                AffectedChips = new[] { "SDM632", "SDA632" },
                SuccessRate = 3
            }},
            
            // SDM630 - Signature Bypass
            { 0x000AC0E1, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Loader Signature Bypass",
                Description = "Certain versions of SDM630 (Snapdragon 630) can load unsigned Loader",
                AffectedChips = new[] { "SDM630", "SDA630" },
                SuccessRate = 3
            }},
            
            // ======================= Snapdragon 4xx/2xx Series =======================
            
            // MSM8953 - Sahara Vulnerability
            { 0x000460E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "Certain versions of MSM8953 (Snapdragon 625) have Sahara protocol vulnerabilities",
                AffectedChips = new[] { "MSM8953", "APQ8053" },
                SuccessRate = 3
            }},
            
            // MSM8937 - Legacy PBL Vulnerability
            { 0x0004F0E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Legacy PBL Exploit",
                Description = "Legacy PBL of MSM8937 (Snapdragon 430) has multiple vulnerabilities",
                AffectedChips = new[] { "MSM8937", "APQ8037" },
                SuccessRate = 4
            }},
            
            // MSM8917 - Sahara Vulnerability
            { 0x000510E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "Certain versions of MSM8917 (Snapdragon 425) have Sahara protocol vulnerabilities",
                AffectedChips = new[] { "MSM8917", "APQ8017" },
                SuccessRate = 3
            }},
            
            // MSM8916 - Classic Vulnerability
            { 0x007050E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "EDL Classic Exploit",
                Description = "MSM8916 (Snapdragon 410) has multiple known EDL exploits",
                AffectedChips = new[] { "MSM8916", "APQ8016", "MSM8216", "MSM8116" },
                SuccessRate = 5
            }},
            
            // MSM8909 - Entry-level Chip Vulnerability
            { 0x009600E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "Legacy PBL of MSM8909 (Snapdragon 210) has vulnerabilities",
                AffectedChips = new[] { "MSM8909", "APQ8009" },
                SuccessRate = 4
            }},
            
            // ======================= Legacy MSM Series =======================
            
            // MSM8974 - Snapdragon 800/801
            { 0x007B00E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Legacy EDL Exploit",
                Description = "MSM8974 (Snapdragon 800) has multiple known EDL exploits",
                AffectedChips = new[] { "MSM8974", "APQ8074" },
                SuccessRate = 5
            }},
            { 0x007B20E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Legacy EDL Exploit",
                Description = "MSM8974-AB (Snapdragon 801) has multiple known EDL exploits",
                AffectedChips = new[] { "MSM8974-AB" },
                SuccessRate = 5
            }},
            
            // MSM8926/8926 - Snapdragon 400
            { 0x007100E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Legacy EDL Exploit",
                Description = "MSM8926 (Snapdragon 400) has known EDL exploit",
                AffectedChips = new[] { "MSM8926", "MSM8226", "MSM8626" },
                SuccessRate = 5
            }},
            
            // MSM8939 - Snapdragon 615/616
            { 0x009290E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "MSM8939 (Snapdragon 615) has Sahara protocol vulnerability",
                AffectedChips = new[] { "MSM8939", "APQ8039" },
                SuccessRate = 4
            }},
            
            // MSM8976 - Snapdragon 652
            { 0x009900E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "Certain versions of MSM8976 (Snapdragon 652) have Sahara vulnerability",
                AffectedChips = new[] { "MSM8976", "APQ8076" },
                SuccessRate = 3
            }},
            
            // MSM8952 - Snapdragon 617
            { 0x009720E1, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "Sahara Protocol Exploit",
                Description = "Certain versions of MSM8952 (Snapdragon 617) have Sahara vulnerability",
                AffectedChips = new[] { "MSM8952" },
                SuccessRate = 3
            }},
        };

        // Known vulnerable vendor OEM ID
        // ============================================================================
        private static readonly Dictionary<ushort, VulnerabilityInfo> VulnerableVendors = new Dictionary<ushort, VulnerabilityInfo>
        {
            // Unfused Devices
            { 0x0000, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Unfused/Engineering Device",
                Description = "OEM ID is 0, possibly engineering or unfused device",
                AffectedVendors = new[] { "Unknown/Engineering" },
                SuccessRate = 5
            }},
            
            // Qualcomm official test devices
            { 0x0001, new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Qualcomm Test Device",
                Description = "Qualcomm test device, possibly using test keys",
                AffectedVendors = new[] { "Qualcomm Test" },
                SuccessRate = 4
            }},
        };

        // Known potentially vulnerable vendors (Historically leaked Loaders)
        // ============================================================================
        private static readonly HashSet<ushort> PotentiallyVulnerableVendors = new HashSet<ushort>
        {
            0x0020,  // Samsung (Certain legacy devices)
            0x0029,  // Asus
            0x0031,  // LG
            0x0072,  // Xiaomi (Certain legacy devices leaked Loaders)
            0x0051,  // Oppo/OnePlus (Certain versions)
            0x00C8,  // Motorola
            0x0017,  // Lenovo
        };

        // Known vulnerable PK Hash prefixes
        // ============================================================================
        private static readonly Dictionary<string, VulnerabilityInfo> VulnerablePkHash = new Dictionary<string, VulnerabilityInfo>
        {
            // Unfused/Test devices
            { "00000000", new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Test Key / Unfused",
                Description = "PK Hash is all zeros, device is unfused or using test key",
                SuccessRate = 5
            }},
            
            // All F (Another unfused flag)
            { "ffffffff", new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Unfused Device (All F)",
                Description = "PK Hash is all F, device is unfused",
                SuccessRate = 5
            }},
            
            // Qualcomm test keys (Known leaks)
            { "cc3153a8", new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Qualcomm Test Key",
                Description = "Using Qualcomm test key, possibly loading generic Loader",
                SuccessRate = 4
            }},
            { "7be49b72", new VulnerabilityInfo {
                Type = ExploitType.SignatureBypass,
                Name = "Qualcomm Debug Key",
                Description = "Using Qualcomm debug key, possibly loading generic Loader",
                SuccessRate = 4
            }},
        };

        // Known vulnerable PBL versions
        // ============================================================================
        private static readonly Dictionary<uint, VulnerabilityInfo> VulnerablePblVersions = new Dictionary<uint, VulnerabilityInfo>
        {
            { 0x00000001, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "PBL v1 Sahara Exploit",
                Description = "PBL version 1 has Sahara protocol vulnerabilities",
                SuccessRate = 4
            }},
            { 0x00000002, new VulnerabilityInfo {
                Type = ExploitType.SaharaOverflow,
                Name = "PBL v2 Sahara Exploit",
                Description = "PBL version 2 has Sahara protocol vulnerabilities",
                SuccessRate = 3
            }},
        };

        /// <summary>
        /// Detect available vulnerabilities based on chip information
        /// </summary>
        /// <param name="msmId">MSM ID (Chip ID)</param>
        /// <param name="oemId">OEM ID (Vendor ID)</param>
        /// <param name="pkHash">PK Hash (First 8 characters)</param>
        /// <param name="pblVersion">PBL Version (Optional)</param>
        /// <returns>Vulnerability detection result</returns>
        public static VulnerabilityCheckResult CheckVulnerabilities(
            uint msmId, 
            ushort oemId, 
            string pkHash, 
            uint pblVersion = 0)
        {
            var result = new VulnerabilityCheckResult();

            // 1. Check if chip has known vulnerability
            VulnerabilityInfo chipVuln;
            if (VulnerableChips.TryGetValue(msmId, out chipVuln))
            {
                result.HasVulnerability = true;
                result.AvailableExploits.Add(chipVuln);
            }

            // 2. Check if vendor has known vulnerability
            VulnerabilityInfo vendorVuln;
            if (VulnerableVendors.TryGetValue(oemId, out vendorVuln))
            {
                result.HasVulnerability = true;
                result.AvailableExploits.Add(vendorVuln);
            }

            // 3. Check if PK Hash has known vulnerability
            if (!string.IsNullOrEmpty(pkHash) && pkHash.Length >= 8)
            {
                string prefix = pkHash.Substring(0, 8).ToLower();
                VulnerabilityInfo pkVuln;
                if (VulnerablePkHash.TryGetValue(prefix, out pkVuln))
                {
                    result.HasVulnerability = true;
                    result.AvailableExploits.Add(pkVuln);
                }
            }

            // 4. Check if PBL version has known vulnerability
            if (pblVersion > 0)
            {
                VulnerabilityInfo pblVuln;
                if (VulnerablePblVersions.TryGetValue(pblVersion, out pblVuln))
                {
                    result.HasVulnerability = true;
                    result.AvailableExploits.Add(pblVuln);
                }
            }

            // 5. Determine recommended exploit method
            if (result.HasVulnerability && result.AvailableExploits.Count > 0)
            {
                // Sort by success rate, select the highest
                VulnerabilityInfo best = result.AvailableExploits[0];
                foreach (var vuln in result.AvailableExploits)
                {
                    if (vuln.SuccessRate > best.SuccessRate)
                        best = vuln;
                }
                result.RecommendedExploit = best.Name;
                result.Reason = best.Description;
            }

            return result;
        }

        /// <summary>
        /// Get vulnerability description of a chip
        /// </summary>
        public static string GetChipVulnerabilityDescription(uint msmId)
        {
            VulnerabilityInfo info;
            if (VulnerableChips.TryGetValue(msmId, out info))
            {
                return string.Format("{0} ({1}â˜…)", info.Name, info.SuccessRate);
            }
            return null;
        }

        /// <summary>
        /// Determine if the chip is potentially vulnerable
        /// </summary>
        public static bool IsChipPotentiallyVulnerable(uint msmId)
        {
            // Known vulnerable chips
            if (VulnerableChips.ContainsKey(msmId))
                return true;

            // Chips before 2018 are more likely to have vulnerabilities
            // MSM8xxx Series (Old architecture)
            if ((msmId & 0x00FF0000) == 0)
                return true;

            return false;
        }

        /// <summary>
        /// Determine if it's an unfused device
        /// </summary>
        public static bool IsUnfusedDevice(ushort oemId, string pkHash)
        {
            // OEM ID is 0
            if (oemId == 0)
                return true;

            // PK Hash is all zeros or all F
            if (!string.IsNullOrEmpty(pkHash))
            {
                string lower = pkHash.ToLowerInvariant();
                if (lower.StartsWith("00000000") || lower.StartsWith("ffffffff"))
                    return true;
                    
                // Check if all characters are the same
                if (lower.Length >= 8)
                {
                    char first = lower[0];
                    bool allSame = true;
                    for (int i = 1; i < 8 && allSame; i++)
                    {
                        if (lower[i] != first)
                            allSame = false;
                    }
                    if (allSame)
                        return true;
                }
            }

            return false;
        }

        /// <summary>
        /// Check if the vendor potentially has leaked Loaders
        /// </summary>
        public static bool IsVendorPotentiallyVulnerable(ushort oemId)
        {
            return VulnerableVendors.ContainsKey(oemId) || PotentiallyVulnerableVendors.Contains(oemId);
        }

        /// <summary>
        /// Get exploit recommendation for a chip
        /// </summary>
        public static ExploitRecommendation GetExploitRecommendation(uint msmId, ushort oemId, string pkHash, uint pblVersion)
        {
            var rec = new ExploitRecommendation();
            var checkResult = CheckVulnerabilities(msmId, oemId, pkHash, pblVersion);
            
            rec.HasKnownVulnerability = checkResult.HasVulnerability;
            rec.AvailableExploits = checkResult.AvailableExploits;
            
            // 1. Unfused device - Load unsigned Loader directly
            if (IsUnfusedDevice(oemId, pkHash))
            {
                rec.Strategy = ExploitStrategy.LoadUnsignedLoader;
                rec.Description = "Device is unfused, can load unsigned Loader directly";
                rec.SuccessChance = 95;
                return rec;
            }
            
            // 2. Check for chip-specific vulnerabilities
            if (checkResult.HasVulnerability && checkResult.AvailableExploits.Count > 0)
            {
                var best = checkResult.AvailableExploits[0];
                foreach (var vuln in checkResult.AvailableExploits)
                {
                    if (vuln.SuccessRate > best.SuccessRate)
                        best = vuln;
                }
                
                rec.Strategy = GetStrategyFromExploitType(best.Type);
                rec.Description = best.Description;
                rec.SuccessChance = best.SuccessRate * 20; // Convert to percentage
                return rec;
            }
            
            // 3. Check for leaked Loaders
            if (IsVendorPotentiallyVulnerable(oemId))
            {
                rec.Strategy = ExploitStrategy.UseLeakedLoader;
                rec.Description = "Leaked Loader may be available for this vendor";
                rec.SuccessChance = 50;
                return rec;
            }
            
            // 4. No known vulnerabilities
            rec.Strategy = ExploitStrategy.None;
            rec.Description = "No known vulnerabilities detected, requires signed Loader or vendor authentication";
            rec.SuccessChance = 10;
            
            return rec;
        }

        private static ExploitStrategy GetStrategyFromExploitType(ExploitType type)
        {
            switch (type)
            {
                case ExploitType.SignatureBypass:
                    return ExploitStrategy.LoadUnsignedLoader;
                case ExploitType.SaharaOverflow:
                    return ExploitStrategy.SaharaExploit;
                case ExploitType.FirehoseXmlOverflow:
                    return ExploitStrategy.FirehoseExploit;
                case ExploitType.PblBufferOverflow:
                    return ExploitStrategy.PblExploit;
                default:
                    return ExploitStrategy.None;
            }
        }

        /// <summary>
        /// Get list of all known vulnerable chip IDs
        /// </summary>
        public static List<uint> GetAllVulnerableChipIds()
        {
            return new List<uint>(VulnerableChips.Keys);
        }

        /// <summary>
        /// Get statistics of the exploit database
        /// </summary>
        public static ExploitDatabaseStats GetStats()
        {
            var stats = new ExploitDatabaseStats();
            stats.TotalVulnerableChips = VulnerableChips.Count;
            stats.TotalVulnerableVendors = VulnerableVendors.Count;
            stats.TotalVulnerablePkHashes = VulnerablePkHash.Count;
            stats.TotalVulnerablePblVersions = VulnerablePblVersions.Count;
            
            // Count by exploit type
            foreach (var vuln in VulnerableChips.Values)
            {
                if (!stats.ChipsByExploitType.ContainsKey(vuln.Type))
                    stats.ChipsByExploitType[vuln.Type] = 0;
                stats.ChipsByExploitType[vuln.Type]++;
            }
            
            return stats;
        }
    }

    /// <summary>
    /// Exploit strategy
    /// </summary>
    public enum ExploitStrategy
    {
        None,                   // No available strategy
        LoadUnsignedLoader,     // Load unsigned Loader directly
        UseLeakedLoader,        // Use leaked Loader
        SaharaExploit,          // Sahara protocol vulnerability
        FirehoseExploit,        // Firehose vulnerability
        PblExploit              // PBL vulnerability
    }

    /// <summary>
    /// Exploit recommendation
    /// </summary>
    public class ExploitRecommendation
    {
        public bool HasKnownVulnerability { get; set; }
        public ExploitStrategy Strategy { get; set; }
        public string Description { get; set; }
        public int SuccessChance { get; set; }  // 0-100%
        public List<VulnerabilityInfo> AvailableExploits { get; set; }
        
        public ExploitRecommendation()
        {
            AvailableExploits = new List<VulnerabilityInfo>();
            Strategy = ExploitStrategy.None;
            Description = "";
            SuccessChance = 0;
        }
        
        public override string ToString()
        {
            return string.Format("Strategy: {0}, Success: {1}%, Desc: {2}", 
                Strategy, SuccessChance, Description);
        }
    }

    /// <summary>
    /// Exploit database statistics
    /// </summary>
    public class ExploitDatabaseStats
    {
        public int TotalVulnerableChips { get; set; }
        public int TotalVulnerableVendors { get; set; }
        public int TotalVulnerablePkHashes { get; set; }
        public int TotalVulnerablePblVersions { get; set; }
        public Dictionary<ExploitType, int> ChipsByExploitType { get; set; }
        
        public ExploitDatabaseStats()
        {
            ChipsByExploitType = new Dictionary<ExploitType, int>();
        }
        
        public override string ToString()
        {
            var sb = new System.Text.StringBuilder();
            sb.AppendLine("Exploit Database Statistics:");
            sb.AppendLine(string.Format("  Known vulnerable chips: {0}", TotalVulnerableChips));
            sb.AppendLine(string.Format("  Known vulnerable vendors: {0}", TotalVulnerableVendors));
            sb.AppendLine(string.Format("  Known vulnerable PK Hashes: {0}", TotalVulnerablePkHashes));
            sb.AppendLine(string.Format("  Known vulnerable PBL versions: {0}", TotalVulnerablePblVersions));
            sb.AppendLine("  Distribution by exploit type:");
            foreach (var kvp in ChipsByExploitType)
            {
                sb.AppendLine(string.Format("    {0}: {1}", kvp.Key, kvp.Value));
            }
            return sb.ToString();
        }
    }
}
