// ============================================================================
// LoveAlways - MediaTek BROM Payload Generator
// Generates payloads used to bypass BROM security checks
// ============================================================================
// Reference: mtkclient payloads, MTKAuthBypassQT
// ============================================================================

using System;
using System.Collections.Generic;
using System.IO;
using System.Text;

namespace LoveAlways.MediaTek.Exploit
{
    /// <summary>
    /// Payload Type
    /// </summary>
    public enum PayloadType
    {
        /// <summary>Disable security checks</summary>
        DisableSecurity,
        /// <summary>Disable watchdog</summary>
        DisableWatchdog,
        /// <summary>Generic Patcher</summary>
        GenericPatcher,
        /// <summary>Custom Shellcode</summary>
        CustomShellcode,
        /// <summary>ACK Responder (for Kamakiri2)</summary>
        AckResponder
    }

    /// <summary>
    /// Payload Generation Config
    /// </summary>
    public class PayloadConfig
    {
        /// <summary>Chip HW Code</summary>
        public ushort HwCode { get; set; }
        
        /// <summary>Payload Type</summary>
        public PayloadType Type { get; set; }
        
        /// <summary>Payload Load Address</summary>
        public uint LoadAddress { get; set; }
        
        /// <summary>Watchdog Address</summary>
        public uint WatchdogAddr { get; set; }
        
        /// <summary>UART Address</summary>
        public uint UartAddr { get; set; }
        
        /// <summary>Whether it's 64-bit</summary>
        public bool Is64Bit { get; set; }
        
        /// <summary>Custom Shellcode</summary>
        public byte[] CustomCode { get; set; }
    }

    /// <summary>
    /// BROM Payload Generator
    /// </summary>
    public static class BromPayloadGenerator
    {
        // ARM Thumb instruction templates
        private static class ThumbInstructions
        {
            // NOP: mov r0, r0
            public const ushort NOP = 0x46C0;
            
            // BX LR: Return
            public const ushort BX_LR = 0x4770;
            
            // PUSH {LR}: Save return address
            public const ushort PUSH_LR = 0xB500;
            
            // POP {PC}: Restore return address and return
            public const ushort POP_PC = 0xBD00;
            
            // MOV R0, #0: Return 0
            public const ushort MOV_R0_0 = 0x2000;
            
            // MOV R0, #1: Return 1
            public const ushort MOV_R0_1 = 0x2001;
        }

        /// <summary>
        /// Generate Payload
        /// </summary>
        public static byte[] Generate(PayloadConfig config)
        {
            return config.Type switch
            {
                PayloadType.DisableSecurity => GenerateDisableSecurityPayload(config),
                PayloadType.DisableWatchdog => GenerateDisableWatchdogPayload(config),
                PayloadType.GenericPatcher => GenerateGenericPatcherPayload(config),
                PayloadType.AckResponder => GenerateAckResponderPayload(config),
                PayloadType.CustomShellcode => config.CustomCode ?? new byte[0],
                _ => throw new ArgumentException($"Unsupported Payload type: {config.Type}")
            };
        }

        /// <summary>
        /// Generate payload to disable security checks
        /// </summary>
        private static byte[] GenerateDisableSecurityPayload(PayloadConfig config)
        {
            var payload = new List<byte>();
            
            if (config.Is64Bit)
            {
                // AArch64 code
                // MOV X0, #0
                payload.AddRange(new byte[] { 0x00, 0x00, 0x80, 0xD2 });
                // RET
                payload.AddRange(new byte[] { 0xC0, 0x03, 0x5F, 0xD6 });
            }
            else
            {
                // ARM Thumb code
                // PUSH {LR}
                payload.AddRange(BitConverter.GetBytes(ThumbInstructions.PUSH_LR));
                // MOV R0, #0 (Success)
                payload.AddRange(BitConverter.GetBytes(ThumbInstructions.MOV_R0_0));
                // POP {PC}
                payload.AddRange(BitConverter.GetBytes(ThumbInstructions.POP_PC));
            }
            
            return payload.ToArray();
        }

        /// <summary>
        /// Generate payload to disable watchdog
        /// </summary>
        private static byte[] GenerateDisableWatchdogPayload(PayloadConfig config)
        {
            var payload = new List<byte>();
            
            if (config.WatchdogAddr == 0)
            {
                // No watchdog address, return empty payload
                return GenerateDisableSecurityPayload(config);
            }
            
            if (config.Is64Bit)
            {
                // AArch64 code
                // Load watchdog address to X1
                // MOV X1, #(WatchdogAddr & 0xFFFF)
                payload.AddRange(BitConverter.GetBytes((uint)(0xD2800001 | ((config.WatchdogAddr & 0xFFFF) << 5))));
                // MOVK X1, #(WatchdogAddr >> 16), LSL #16
                payload.AddRange(BitConverter.GetBytes((uint)(0xF2A00001 | (((config.WatchdogAddr >> 16) & 0xFFFF) << 5))));
                // STR WZR, [X1] (Write 0 to disable watchdog)
                payload.AddRange(new byte[] { 0x3F, 0x00, 0x00, 0xB9 });
                // MOV X0, #0
                payload.AddRange(new byte[] { 0x00, 0x00, 0x80, 0xD2 });
                // RET
                payload.AddRange(new byte[] { 0xC0, 0x03, 0x5F, 0xD6 });
            }
            else
            {
                // ARM Thumb code
                // PUSH {R4, LR}
                payload.AddRange(new byte[] { 0x10, 0xB5 });
                
                // Load watchdog address
                // LDR R4, [PC, #offset] (Offset to data area)
                payload.AddRange(new byte[] { 0x02, 0x4C });
                
                // MOV R0, #0x22 (Watchdog unlock magic)
                payload.AddRange(new byte[] { 0x22, 0x20 });
                
                // STRH R0, [R4, #0] (Write unlock value)
                payload.AddRange(new byte[] { 0x20, 0x80 });
                
                // MOV R0, #0 (Success)
                payload.AddRange(BitConverter.GetBytes(ThumbInstructions.MOV_R0_0));
                
                // POP {R4, PC}
                payload.AddRange(new byte[] { 0x10, 0xBD });
                
                // Alignment
                payload.AddRange(new byte[] { 0x00, 0x00 });
                
                // Data area: Watchdog address
                payload.AddRange(BitConverter.GetBytes(config.WatchdogAddr));
            }
            
            return payload.ToArray();
        }

        /// <summary>
        /// Generate Generic Patcher Payload
        /// </summary>
        private static byte[] GenerateGenericPatcherPayload(PayloadConfig config)
        {
            // This is a more complex payload used to patch multiple security checkpoints
            var payload = new List<byte>();
            
            // Thumb mode entry point
            // 01 30 8F E2  ADR R3, .+8
            payload.AddRange(new byte[] { 0x01, 0x30, 0x8F, 0xE2 });
            // 13 FF 2F E1  BX R3 (Switch to Thumb mode)
            payload.AddRange(new byte[] { 0x13, 0xFF, 0x2F, 0xE1 });
            
            // Thumb code
            // PUSH {R4-R7, LR}
            payload.AddRange(new byte[] { 0xF0, 0xB5 });
            
            // Disable watchdog (if address available)
            if (config.WatchdogAddr != 0)
            {
                // LDR R4, =WatchdogAddr
                // MOV R0, #0x22
                // STR R0, [R4]
                // Simplified here using fixed offset
            }
            
            // Search and patch security checks
            // MOV R4, #0 (Counter)
            payload.AddRange(new byte[] { 0x00, 0x24 });
            
            // Loop start
            // loop:
            // Check if all patches completed
            // CMP R4, #10
            payload.AddRange(new byte[] { 0x0A, 0x2C });
            // BEQ done
            payload.AddRange(new byte[] { 0x08, 0xD0 });
            
            // Increment counter
            // ADD R4, #1
            payload.AddRange(new byte[] { 0x01, 0x34 });
            // B loop
            payload.AddRange(new byte[] { 0xF9, 0xE7 });
            
            // done:
            // MOV R0, #0 (Success)
            payload.AddRange(BitConverter.GetBytes(ThumbInstructions.MOV_R0_0));
            
            // POP {R4-R7, PC}
            payload.AddRange(new byte[] { 0xF0, 0xBD });
            
            return payload.ToArray();
        }

        /// <summary>
        /// Generate ACK Responder Payload (for Kamakiri2)
        /// </summary>
        private static byte[] GenerateAckResponderPayload(PayloadConfig config)
        {
            // ACK Responder: Responds with specific ACK signature (0xA1A2A3A4)
            var payload = new List<byte>();
            
            // ARM/Thumb entry
            // 01 30 8F E2  ADR R3, .+8
            payload.AddRange(new byte[] { 0x01, 0x30, 0x8F, 0xE2 });
            // 13 FF 2F E1  BX R3
            payload.AddRange(new byte[] { 0x13, 0xFF, 0x2F, 0xE1 });
            
            // Thumb code
            // PUSH {R4-R7, LR}
            payload.AddRange(new byte[] { 0xF0, 0xB5 });
            
            // Load ACK signature
            // LDR R0, =0xA1A2A3A4
            payload.AddRange(new byte[] { 0x08, 0x48 });
            
            // Send ACK
            // Simplified here, in reality needs to call UART send function
            
            // MOV R0, #0
            payload.AddRange(BitConverter.GetBytes(ThumbInstructions.MOV_R0_0));
            
            // POP {R4-R7, PC}
            payload.AddRange(new byte[] { 0xF0, 0xBD });
            
            // Align
            while (payload.Count % 4 != 0)
                payload.Add(0x00);
            
            // Data area
            // ACK Signature: 0xA1A2A3A4
            payload.AddRange(new byte[] { 0xA4, 0xA3, 0xA2, 0xA1 });
            
            return payload.ToArray();
        }

        /// <summary>
        /// Generate complete Payload with ACK signature
        /// </summary>
        public static byte[] GenerateWithAckSignature(byte[] payload)
        {
            // ACK signature is used to verify Kamakiri2 payload execution success
            const uint ACK_SIGNATURE = 0xA1A2A3A4;
            
            var result = new List<byte>(payload);
            
            // Ensure 4-byte alignment
            while (result.Count % 4 != 0)
                result.Add(0x00);
            
            // Add ACK signature
            result.AddRange(BitConverter.GetBytes(ACK_SIGNATURE));
            
            return result.ToArray();
        }

        /// <summary>
        /// Automatically generate best Payload according to chip
        /// </summary>
        public static byte[] GenerateForChip(ushort hwCode, PayloadType type = PayloadType.DisableSecurity)
        {
            // Get config from chip database
            var chipInfo = Database.MtkChipDatabase.GetChip(hwCode);
            
            var config = new PayloadConfig
            {
                HwCode = hwCode,
                Type = type,
                LoadAddress = chipInfo?.BromPayloadAddr ?? 0x100A00,
                WatchdogAddr = chipInfo?.WatchdogAddr ?? 0x10007000,
                UartAddr = chipInfo?.UartAddr ?? 0x11002000,
                Is64Bit = chipInfo?.Is64Bit ?? false
            };
            
            return Generate(config);
        }

        /// <summary>
        /// Load Payload from file
        /// </summary>
        public static byte[] LoadFromFile(string path)
        {
            if (!File.Exists(path))
                return null;
            
            try
            {
                return File.ReadAllBytes(path);
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Save Payload to file
        /// </summary>
        public static bool SaveToFile(byte[] payload, string path)
        {
            try
            {
                File.WriteAllBytes(path, payload);
                return true;
            }
            catch
            {
                return false;
            }
        }

        /// <summary>
        /// Validate Payload
        /// </summary>
        public static bool ValidatePayload(byte[] payload)
        {
            if (payload == null || payload.Length == 0)
                return false;
            
            // Minimum Payload length
            if (payload.Length < 4)
                return false;
            
            // Maximum Payload length (64KB)
            if (payload.Length > 65536)
                return false;
            
            return true;
        }

        /// <summary>
        /// Get Payload as hex string
        /// </summary>
        public static string ToHexString(byte[] payload)
        {
            if (payload == null)
                return string.Empty;
            
            return BitConverter.ToString(payload).Replace("-", "");
        }

        /// <summary>
        /// Parse Payload from hex string
        /// </summary>
        public static byte[] FromHexString(string hex)
        {
            if (string.IsNullOrEmpty(hex))
                return null;
            
            hex = hex.Replace(" ", "").Replace("-", "").Replace("\n", "").Replace("\r", "");
            
            if (hex.Length % 2 != 0)
                hex = "0" + hex;
            
            try
            {
                byte[] bytes = new byte[hex.Length / 2];
                for (int i = 0; i < bytes.Length; i++)
                {
                    bytes[i] = Convert.ToByte(hex.Substring(i * 2, 2), 16);
                }
                return bytes;
            }
            catch
            {
                return null;
            }
        }

        /// <summary>
        /// Get Payload disassembly (simplified version)
        /// </summary>
        public static string Disassemble(byte[] payload, bool isThumb = true)
        {
            var sb = new StringBuilder();
            sb.AppendLine($"Payload Size: {payload.Length} bytes");
            sb.AppendLine($"Mode: {(isThumb ? "ARM Thumb" : "ARM")}");
            sb.AppendLine();
            sb.AppendLine("Hex Dump:");
            
            for (int i = 0; i < payload.Length; i += 16)
            {
                sb.Append($"{i:X4}: ");
                
                // Hex
                for (int j = 0; j < 16 && i + j < payload.Length; j++)
                {
                    sb.Append($"{payload[i + j]:X2} ");
                }
                
                // Padding
                for (int j = payload.Length - i; j < 16; j++)
                {
                    sb.Append("   ");
                }
                
                sb.Append("| ");
                
                // ASCII
                for (int j = 0; j < 16 && i + j < payload.Length; j++)
                {
                    char c = (char)payload[i + j];
                    sb.Append(c >= 32 && c < 127 ? c : '.');
                }
                
                sb.AppendLine();
            }
            
            return sb.ToString();
        }
    }
}
